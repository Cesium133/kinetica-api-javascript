/*
 *  This file was autogenerated by the GPUdb schema processor.
 *
 *  DO NOT EDIT DIRECTLY.
 */
/**
 * Creates a GPUdb API object for the specified URL using the given options.
 * Once created, all options are immutable; to use a different URL or change
 * options, create a new instance. (Creating a new instance does not
 * communicate with the server and should not cause performance concerns.)
 *
 * @class
 * @classdesc GPUdb API object that provides access to GPUdb server functions.
 * @param {String} url The URL of the GPUdb server (e.g.,
                   <code>http://hostname:9191</code>).
 * @param {Object} [options] A set of configurable options for the GPUdb API.
 * @param {String} [options.username] The username to be used for authentication
 *                 to GPUdb. This username will be sent with every GPUdb request
 *                 made via the API along with the specified password and may be
 *                 used for authorization decisions by the server if it is so
 *                 configured. If neither username nor password is specified, no
 *                 authentication will be performed.
 * @param {String} [options.password] The password to be used for authentication
 *                 to GPUdb. This password will be sent with every GPUdb request
 *                 made via the API along with the specified username and may be
 *                 used for authorization decisions by the server if it is so
 *                 configured. If neither username nor password is specified, no
 *                 authentication will be performed.
 * @param {String} [options.user_auth] The user authorization string to be used
 *                 when making requests to GPUdb. If specified, any GPUdb
 *                 requests made via the API that support a user authorization
 *                 string will use this value in lieu of any value provided in
 *                 the request itself.
 * @param {Number} [options.timeout] The timeout value, in milliseconds, after
 *                 which requests to GPUdb will be aborted. A timeout value of
 *                 zero is interpreted as an infinite timeout. Note that timeout
 *                 is not suppored for synchronous requests, which will not
 *                 return until a response is received and cannot be aborted.
 */
function GPUdb(url, options) {
    /**
     * The URL of the GPUdb server.
     *
     * @name GPUdb#url
     * @type String
     * @readonly
     */
    Object.defineProperty(this, "url", { enumerable: true, value: url });

    var parsed_url = require("url").parse(url);

    if (parsed_url.protocol !== "http:" && parsed_url.protocol !== "https:") {
        throw new Error("Invald URL specified.");
    }

    Object.defineProperty(this, "protocol", { value: parsed_url.protocol });
    Object.defineProperty(this, "hostname", { value: parsed_url.hostname });
    Object.defineProperty(this, "port", { value: parsed_url.port });
    Object.defineProperty(this, "pathname", { value: parsed_url.pathname.replace(/\/$/, "") });

    if (options !== undefined && options !== null) {
        /**
         * The username used for authentication to GPUdb. Will be an empty
         * string if none was provided to the {@link GPUdb GPUdb contructor}.
         *
         * @name GPUdb#username
         * @type String
         * @readonly
         */
        Object.defineProperty(this, "username", {
            enumerable: true,
            value: options.username !== undefined && options.username !== null ? options.username : ""
        });

        /**
         * The password used for authentication to GPUdb. Will be an empty
         * string if none was provided to the {@link GPUdb GPUdb constructor}.
         *
         * @name GPUdb#password
         * @type String
         * @readonly
         */
        Object.defineProperty(this, "password", {
            enumerable: true,
            value: options.password !== undefined && options.password !== null ? options.password : ""
        });

        /**
         * The user authorization string used when making requests to GPUdb.
         * Will be an empty string if none was provided to the {@link GPUdb
         * GPUdb constructor}.
         *
         * @name GPUdb#password
         * @type String
         * @readonly
         */
        Object.defineProperty(this, "user_auth", {
            enumerable: true,
            value: options.user_auth !== undefined && options.user_auth !== null ? options.user_auth : ""
        });

        /**
         * The timeout value, in milliseconds, after which requests to GPUdb
         * will be aborted. A timeout of zero is interpreted as an infinite
         * timeout. Will be zero if none was provided to the {@link GPUdb GPUdb
         * constructor}.
         *
         * @name GPUdb#timeout
         * @type Number
         * @readonly
         */
        Object.defineProperty(this, "timeout", {
            enumerable: true,
            value: options.timeout !== undefined && options.timeout !== null && options.timeout >= 0 ? options.timeout : 0
        });
    } else {
        Object.defineProperty(this, "username", { enumerable: true, value: "" });
        Object.defineProperty(this, "password", { enumerable: true, value: "" });
        Object.defineProperty(this, "user_auth", { enumerable: true, value: "" });
        Object.defineProperty(this, "timeout", { enumerable: true, value: 0 });
    }

    if (this.username !== "" || this.password !== "") {
        Object.defineProperty(this, "authorization", {
            value: "Basic " + new Buffer(this.username + ":" + this.password).toString("base64")
        });
    } else {
        Object.defineProperty(this, "authorization", { value: "" });
    }
}

module.exports = GPUdb;

/**
 * Submits an arbitrary request to GPUdb. The response will be returned via the
 * specified callback function, or via a promise if no callback function is
 * provided.
 *
 * @param {String} endpoint The endpoint to which to submit the request.
 * @param {Object} request The request object to submit.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the response object,
 *                    if no callback function is provided.
 */
GPUdb.prototype.submit_request = function(endpoint, request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.submit_request(endpoint, request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var requestString = JSON.stringify(request);

    if (this.protocol === "http:") {
        var http = require("http");
    } else {
        var http = require("https");
    }

    var headers = { "Content-type": "application/json" };

    if (this.user_auth !== "") {
        headers["GPUdb-User-Auth"] = this.user_auth;
    }

    if (this.authorization !== "") {
        headers["Authorization"] = this.authorization;
    }

    var got_error = false;

    var req = http.request({
            hostname: this.hostname,
            port: this.port,
            path: this.pathname + endpoint,
            method: "POST",
            headers: headers
        }, function(res) {
            var responseString = "";

            res.on("data", function(chunk) {
                responseString += chunk;
            });

            res.on("end", function() {
                if (got_error) {
                    return;
                }

                try {
                    var response = JSON.parse(responseString);
                } catch (e) {
                    callback(new Error("Unable to parse response: " + e), null);
                    return;
                }

                if (response.status === "OK") {
                    try {
                        var data = JSON.parse(response.data_str.replace(/\\U/g,"\\u"));
                    } catch (e) {
                        callback(new Error("Unable to parse response: " + e), null);
                        return;
                    }

                    callback(null, data);
                } else {
                    callback(new Error(response.message), null);
                }
            });

            res.on("error", function(err) {
                got_error = true;
                callback(err, null);
            });
        });

    req.on("error", function(err) {
        got_error = true;
        callback(err, null);
    });

    req.setTimeout(this.timeout, function() {
        got_error = true;
        callback(new Error("Request timed out"), null);
    });

    req.write(requestString);
    req.end();
};

/**
 * Request a WMS (Web Map Service) rasterized image. The image will be returned
 * as a Node.js Buffer object via the specified callback function, or via a
 * promise if no callback function is provided.
 *
 * @param {Object} request Object containing WMS parameters.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the image, if no
 *                    callback function is provided.
 */
GPUdb.prototype.wms_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.wms_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var queryString = require("querystring").stringify(request);

    if (this.protocol === "http:") {
        var http = require("http");
    } else {
        var http = require("https");
    }

    var headers = {};

    if (this.user_auth !== "") {
        headers["GPUdb-User-Auth"] = this.user_auth;
    }

    if (this.authorization !== "") {
        headers["Authorization"] = this.authorization;
    }

    var got_error = false;

    var req = http.request({
        hostname: this.hostname,
        port: this.port,
        path: this.pathname + "/wms?" + queryString,
        headers: headers,
    }, function(res) {
        var data = [];

        res.on("data", function(chunk) {
            data.push(chunk);
        });

        res.on("end", function() {
            if (got_error) {
                return;
            }

            callback(null, Buffer.concat(data));
        });

        res.on("error", function(err) {
            got_error = true;
            callback(err, null);
        });
    });

    req.on("error", function(err) {
        got_error = true;
        callback(err, null);
    });

    req.setTimeout(this.timeout, function() {
        got_error = true;
        callback(new Error("Request timed out"), null);
    });

    req.end();
}
/**
 * Callback function used for asynchronous GPUdb calls.
 *
 * @callback GPUdbCallback
 * @param {Error} err Object containing error information returned from the
 *                call. Will be null if no error occurred.
 * @param {Object} response Object containing any data returned from the call.
 *                 Will be null if an error occurred.
 */

/**
 * Creates a Type object containing metadata about a GPUdb type.
 *
 * @class
 * @classdesc Metadata about a GPUdb type.
 * @param {String} label A user-defined description string which can be used to
 *                 differentiate between data with otherwise identical schemas.
 * @param {...GPUdb.Type.Column} columns The list of columns that the type
 *                               comprises.
 */
GPUdb.Type = function(label, columns) {
    /**
     * A user-defined description string which can be used to differentiate
     * between data with otherwise identical schemas.
     *
     * @name GPUdb.Type#label
     * @type String
     */
    this.label = label;

    /**
     * The list of columns that the type comprises.
     *
     * @name GPUdb.Type#columns
     * @type GPUdb.Type.Column[]
     */
    if (Array.isArray(columns)) {
        this.columns = columns;
    } else {
        this.columns = [];

        for (var i = 1; i < arguments.length; i++) {
            this.columns.push(arguments[i]);
        }
    }
};

/**
 * Creates a Column object containing metadata about a column that is part of a
 * GPUdb type.
 *
 * @class
 * @classdesc Metadata about a column that is part of a GPUdb type.
 * @param {String} name The name of the column.
 * @param {String} type The data type of the column.
 * @param {...String} [properties] The list of properties that apply to the
                      column; defaults to none.
 */
GPUdb.Type.Column = function(name, type, properties) {
    /**
     * The name of the column.
     *
     * @name GPUdb.Type.Column#name
     * @type String
     */
    this.name = name;

    /**
     * The data type of the column.
     *
     * @name GPUdb.Type.Column#type
     * @type String
     */
    this.type = type;

    /**
     * The list of properties that apply to the column.
     *
     * @name GPUdb.Type.Column#properties
     * @type String[]
     */
    if (properties !== undefined && properties !== null) {
        if (Array.isArray(properties)) {
            this.properties = properties;
        } else {
            this.properties = [];

            for (var i = 2; i < arguments.length; i++) {
                this.properties.push(arguments[i]);
            }
        }
    } else {
        this.properties = [];
    }
};

/**
 * Creates a Type object using data returned from the GPUdb show_table or
 * show_types endpoints.
 *
 * @param {String} label A user-defined description string which can be used to
 *                 differentiate between data with otherwise identical schemas.
 * @param {String|Object} type_schema The Avro record schema for the type.
 * @param {Object.<String, String[]>} properties A map of column names to
 *                                    lists of properties that apply to those
 *                                    columns.
 * @returns {GPUdb.Type} The Type object.
 */
GPUdb.Type.from_type_info = function(label, type_schema, properties) {
    if (typeof type_schema === "string" || type_schema instanceof String) {
        type_schema = JSON.parse(type_schema);
    }

    var columns = [];

    for (var i = 0; i < type_schema.fields.length; i++) {
        var field = type_schema.fields[i];
        columns.push(new GPUdb.Type.Column(field.name, field.type, properties[field.name]));
    }

    return new GPUdb.Type(label, columns);
};

/**
 * Generates an Avro record schema based on the metadata in the Type object.
 *
 * @returns {Object} The Avro record schema.
 */
GPUdb.Type.prototype.generate_schema = function() {
    var schema = {
        type: "record",
        name: "type_name",
        fields: []
    };

    for (var i = 0; i < this.columns.length; i++) {
        var column = this.columns[i];

        schema.fields.push({
            name: column.name,
            type: column.type
        });
    }

    return schema;
};

/**
 * The version number of the GPUdb JavaScript API.
 *
 * @name GPUdb#api_version
 * @type String
 * @readonly
 * @static
 */
Object.defineProperty(GPUdb, "api_version", { enumerable: true, value: "5.2.0" });

/**
 * Decodes a JSON string, or array of JSON strings, returned from GPUdb into
 * JSON object(s).
 *
 * @param {String | String[]} o The JSON string(s) to decode.
 * @returns {Object | Object[]} The decoded JSON object(s).
 */
GPUdb.decode = function(o) {
    if (Array.isArray(o)) {
        var result = [];

        for (var i = 0; i < o.length; i++) {
            result.push(GPUdb.decode(o[i]));
        }

        return result;
    } else {
        return JSON.parse(o);
    }
};

/**
 * Encodes a JSON object, or array of JSON objects, into JSON string(s) to be
 * passed to GPUdb.
 *
 * @param {Object | Object[]} o The JSON object(s) to encode.
 * @returns {String | String[]} The encoded JSON string(s).
 */
GPUdb.encode = function(o) {
    if (Array.isArray(o)) {
        var result = [];

        for (var i = 0; i < o.length; i++) {
            result.push(GPUdb.encode(o[i]));
        }

        return result;
    } else {
        return JSON.stringify(o);
    }
};
/**
 * Creates a Type object containing metadata about the type stored in the
 * specified table in GPUdb and returns it via the specified callback function,
 * or via a promise if no callback function is provided.
 *
 * @param {GPUdb} gpudb GPUdb API object.
 * @param {String} table_name The table from which to obtain type metadata.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the type object, if
 *                    no callback function is provided.
 */
GPUdb.Type.from_table = function(gpudb, table_name, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.from_table(gpudb, table_name, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var process_response = function(response, callback) {
        if (response.type_ids.length === 0) {
            callback(new Error("Table " + table_name + " does not exist."), null);
        }

        if (response.type_ids.length > 1) {
            var type_id = response.type_ids[0];

            for (var i = 1; i < response.type_ids.length; i++) {
                if (response.type_ids[i] !== type_id) {
                    callback(new Error("Table " + table_name + " is not homogeneous."), null);
                }
            }
        }

        callback(null, GPUdb.Type.from_type_info(response.type_labels[0], response.type_schemas[0], response.properties[0]));
    };

    gpudb.show_table(table_name, {}, function(err, data) {
        if (err === null) {
            process_response(data, callback);
        } else {
            callback(err, null);
        }
    });
};

/**
 * Creates a Type object containing metadata about the specified type in GPUdb
 * and returns it via the specified callback function, or via a promise if no
 * callback function is provided.
 *
 * @param {GPUdb} gpudb GPUdb API object.
 * @param {String} type_id The type for which to obtain metadata.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the type object, if
 *                    no callback function is provided.
 */
GPUdb.Type.from_type = function(gpudb, type_id, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.from_type(gpudb, type_id, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var process_response = function(response, callback) {
        if (response.type_ids.length === 0) {
            callback(Error("Type " + type_id + " does not exist."), null);
        }

        callback(null, GPUdb.Type.from_type_info(response.labels[0], response.type_schemas[0], response.properties[0]));
    };

    gpudb.show_types(type_id, "", {}, function(err, data) {
        if (err === null) {
            process_response(data, callback);
        } else {
            callback(err, null);
        }
    });
};

/**
 * Creates a new type in GPUdb based on the metadata in the Type object and
 * returns the GPUdb type ID via the specified callback function, or via a
 * promise if no callback function is provided, for use in subsequent
 * operations.
 *
 * @param {GPUdb} gpudb GPUdb API object.
 * @param {GPUdbCallback} [callback] The callback function.
 * @returns {Promise} A promise that will be fulfilled with the type ID, if no
 *                    callback function is provided.
 */
GPUdb.Type.prototype.create = function(gpudb, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise(function(resolve, reject) {
            self.create(gpudb, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve(response);
                }
            });
        });
    }

    var properties = {};

    for (var i = 0; i < this.columns.length; i++) {
        var column = this.columns[i];

        if (column.properties.length > 0) {
            properties[column.name] = column.properties;
        }
    }

    gpudb.create_type(JSON.stringify(this.generate_schema()), this.label, properties, {}, function(err, data) {
        if (err === null) {
            callback(null, data.type_id);
        } else {
            callback(err, null);
        }
    });
};

/**
 * Delete a node from the system.  To delete a node, the data is first
 * distributed from the deleted node to all the other nodes.  Then the node is
 * taken out of service.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_delete_node_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_delete_node_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        rank: request.rank,
        authorization: request.authorization,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/delete/node", actual_request, callback);
};

/**
 * Delete a node from the system.  To delete a node, the data is first
 * distributed from the deleted node to all the other nodes.  Then the node is
 * taken out of service.
 *
 * @param {Number} rank  Rank number of the node being removed from the system.
 * @param {String} authorization  The password that GPUdb is configured with
 *                                during startup. Incorrect or missing
 *                                authorization code will result in an error.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_delete_node = function(rank, authorization, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_delete_node(rank, authorization, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        rank: rank,
        authorization: authorization,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/delete/node", actual_request, callback);
};

/**
 * Returns the list of shards and the corresponding rank and tom containing the
 * shard.  The response message contains arrays of 16384 (total number of
 * shards in the system) rank and tom numbers corresponding to each shard.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_get_shard_assignments_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_get_shard_assignments_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/getshardassignments", actual_request, callback);
};

/**
 * Returns the list of shards and the corresponding rank and tom containing the
 * shard.  The response message contains arrays of 16384 (total number of
 * shards in the system) rank and tom numbers corresponding to each shard.
 *
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_get_shard_assignments = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_get_shard_assignments(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/getshardassignments", actual_request, callback);
};

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_offline_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_offline_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        offline: request.offline,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/offline", actual_request, callback);
};

/**
 * Take the system offline. When the system is offline, no user operations can
 * be performed with the exception of a system shutdown.
 *
 * @param {Boolean} offline  Set to true if desired state is offline.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_offline = function(offline, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_offline(offline, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        offline: offline,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/offline", actual_request, callback);
};

/**
 * Rebalance the database such that all the nodes contain approximately equal
 * number of records.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_rebalance_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_rebalance_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/rebalance", actual_request, callback);
};

/**
 * Rebalance the database such that all the nodes contain approximately equal
 * number of records.
 *
 * @param {String[]} table_names  Names of the tables to be rebalanced.  If
 *                                array is empty, all tables will be
 *                                rebalanced.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_rebalance = function(table_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_rebalance(table_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/rebalance", actual_request, callback);
};

/**
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_set_shard_assignments_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_set_shard_assignments_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        version: request.version,
        partial_reassignment: request.partial_reassignment,
        shard_assignments_rank: request.shard_assignments_rank,
        shard_assignments_tom: request.shard_assignments_tom,
        assignment_index: request.assignment_index,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/setshardassignments", actual_request, callback);
};

/**
 *
 * @param {Number} version
 * @param {Boolean} partial_reassignment
 * @param {Number[]} shard_assignments_rank
 * @param {Number[]} shard_assignments_tom
 * @param {Number[]} assignment_index
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_set_shard_assignments = function(version, partial_reassignment, shard_assignments_rank, shard_assignments_tom, assignment_index, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_set_shard_assignments(version, partial_reassignment, shard_assignments_rank, shard_assignments_tom, assignment_index, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        version: version,
        partial_reassignment: partial_reassignment,
        shard_assignments_rank: shard_assignments_rank,
        shard_assignments_tom: shard_assignments_tom,
        assignment_index: assignment_index,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/setshardassignments", actual_request, callback);
};

/**
 * Exits the GPUdb server application. A authorization code is required (chosen
 * at the time of GPUdb configuration) to successfully complete this request.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_shutdown_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_shutdown_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        exit_type: request.exit_type,
        authorization: request.authorization,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/shutdown", actual_request, callback);
};

/**
 * Exits the GPUdb server application. A authorization code is required (chosen
 * at the time of GPUdb configuration) to successfully complete this request.
 *
 * @param {String} exit_type  Reserved for future use. User can pass an empty
 *                            string.
 * @param {String} authorization  The password that GPUdb is configured with
 *                                during startup. Incorrect or missing
 *                                authorization code will result in an error.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_shutdown = function(exit_type, authorization, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_shutdown(exit_type, authorization, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        exit_type: exit_type,
        authorization: authorization,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/shutdown", actual_request, callback);
};

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_verify_db_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_verify_db_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/admin/verifydb", actual_request, callback);
};

/**
 * Verify database is in a consistent state.  When inconsistencies or errors
 * are found, the verified_ok flag in the response is set to false and the list
 * of errors found is provided in the error_list.
 *
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.admin_verify_db = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.admin_verify_db(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/admin/verifydb", actual_request, callback);
};

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by {@code table_name}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_convex_hull_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_convex_hull_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/convexhull", actual_request, callback);
};

/**
 * Calculates and returns the convex hull for the values in a table specified
 * by {@code table_name}.
 *
 * @param {String} table_name  Name of Table on which the operation will be
 *                             performed. Must be a valid table in GPUdb.  It
 *                             can not be a collection.
 * @param {String} x_column_name  Name of the column containing the x
 *                                coordinates of the points for the operation
 *                                being performed.
 * @param {String} y_column_name  Name of the column containing the y
 *                                coordinates of the points for the operation
 *                                being performed.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_convex_hull = function(table_name, x_column_name, y_column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_convex_hull(table_name, x_column_name, y_column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/convexhull", actual_request, callback);
};

/**
 * Calculates unique combinations (i.e. groups) of values for the given columns
 * in a given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates.
 * <p>
 * The results can be paged via the {@code offset} and {@code limit}
 * parameters. For example, to get 10 groups with the largest counts the inputs
 * would be: limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * {@code options} can be used to customize behavior of this call e.g.
 * filtering or sorting the results.
 * <p>
 * To group by 'x' and 'y' and compute the number of objects within each group,
 * use column_names=['x','y','count(*)'].  To also compute the sum of 'z' over
 * each group, use column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop' and
 * 'var_samp'.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_group_by_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_group_by_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        offset: request.offset,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 1000,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/groupby", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Calculates unique combinations (i.e. groups) of values for the given columns
 * in a given table/view/collection and computes aggregates on each unique
 * combination. This is somewhat analogous to an SQL-style SELECT...GROUP BY.
 * Any column(s) can be grouped on, but only non-string (i.e. numeric) columns
 * may be used for computing aggregates.
 * <p>
 * The results can be paged via the {@code offset} and {@code limit}
 * parameters. For example, to get 10 groups with the largest counts the inputs
 * would be: limit=10, options={"sort_order":"descending", "sort_by":"value"}.
 * <p>
 * {@code options} can be used to customize behavior of this call e.g.
 * filtering or sorting the results.
 * <p>
 * To group by 'x' and 'y' and compute the number of objects within each group,
 * use column_names=['x','y','count(*)'].  To also compute the sum of 'z' over
 * each group, use column_names=['x','y','count(*)','sum(z)'].
 * <p>
 * Available aggregation functions are: 'count(*)', 'sum', 'min', 'max', 'avg',
 * 'mean', 'stddev', 'stddev_pop', 'stddev_samp', 'var', 'var_pop' and
 * 'var_samp'.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be a valid table/view/collection
 *                             in GPUdb.
 * @param {String[]} column_names  List of one or more column names,
 *                                 expressions, and aggregate expressions. Must
 *                                 include at least one 'grouping' column or
 *                                 expression.  If no aggregate is included,
 *                                 count(*) will be computed as a default.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned Or END_OF_SET (-9999) to
 *                        indicate that the max number of results should be
 *                        returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_group_by = function(table_name, column_names, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_group_by(table_name, column_names, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        offset: offset,
        limit: (limit !== undefined && limit !== null) ? limit : 1000,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/groupby", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The {@code interval} is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is exclusive--
 * except for the very last bin for which the end value is also inclusive.  The
 * value returned for each bin is the number of records in it, except when a
 * column name is provided as a *value_column* in {@code options}.  In this
 * latter case the sum of the values corresponding to the *value_column* is
 * used as the result instead.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_histogram_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_histogram_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        start: request.start,
        end: request.end,
        interval: request.interval,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/histogram", actual_request, callback);
};

/**
 * Performs a histogram calculation given a table, a column, and an interval
 * function. The {@code interval} is used to produce bins of that size and the
 * result, computed over the records falling within each bin, is returned.  For
 * each bin, the start value is inclusive, but the end value is exclusive--
 * except for the very last bin for which the end value is also inclusive.  The
 * value returned for each bin is the number of records in it, except when a
 * column name is provided as a *value_column* in {@code options}.  In this
 * latter case the sum of the values corresponding to the *value_column* is
 * used as the result instead.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be a valid table or collection
 *                             in GPUdb.
 * @param {String} column_name  Name of a column or an expression of one or
 *                              more column names over which the histogram will
 *                              be calculated.
 * @param {Number} start  Lower end value of the histogram interval, inclusive.
 * @param {Number} end  Upper end value of the histogram interval, inclusive.
 * @param {Number} interval  The size of each bin within the start and end
 *                           parameters.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_histogram = function(table_name, column_name, start, end, interval, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_histogram(table_name, column_name, start, end, interval, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        start: start,
        end: end,
        interval: interval,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/histogram", actual_request, callback);
};

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_k_means_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_k_means_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        k: request.k,
        tolerance: request.tolerance,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/kmeans", actual_request, callback);
};

/**
 * This endpoint runs the k-means algorithm - a heuristic algorithm that
 * attempts to do k-means clustering.  An ideal k-means clustering algorithm
 * selects k points such that the sum of the mean squared distances of each
 * member of the set to the nearest of the k points is minimized.  The k-means
 * algorithm however does not necessarily produce such an ideal cluster.   It
 * begins with a randomly selected set of k points and then refines the
 * location of the points iteratively and settles to a local minimum.  Various
 * parameters and options are provided to control the heuristic search.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be a valid table or collection
 *                             in GPUdb.
 * @param {String[]} column_names  List of column names on which the operation
 *                                 would be performed. If n columns are
 *                                 provided then each of the k result points
 *                                 will have n dimensions corresponding to the
 *                                 n columns.
 * @param {Number} k  The number of mean points to be determined by the
 *                    algorithm.
 * @param {Number} tolerance  Stop iterating when the distances between
 *                            successive points is less than the given
 *                            tolerance.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_k_means = function(table_name, column_names, k, tolerance, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_k_means(table_name, column_names, k, tolerance, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        k: k,
        tolerance: tolerance,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/kmeans", actual_request, callback);
};

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_min_max_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_min_max_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/minmax", actual_request, callback);
};

/**
 * Calculates and returns the minimum and maximum values of a particular column
 * in a table.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be a valid table in GPUdb.
 * @param {String} column_name  Name of a column or an expression of one or
 *                              more column on which the min-max will be
 *                              calculated.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_min_max = function(table_name, column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_min_max(table_name, column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/minmax", actual_request, callback);
};

/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e. 'percentile(75.0),percentile(99.0),percentile_
 * rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in {@code options}. The weighted average is then defined as the sum of the
 * products of {@code column_name} times the weight attribute divided by the
 * sum of the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        stats: request.stats,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/statistics", actual_request, callback);
};

/**
 * Calculates the requested statistics of a given column in a given table.
 * <p>
 * The available statistics are count (number of total objects), mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max,
 * weighted_average, cardinality (unique count), estimated cardinality,
 * percentile and percentile_rank.
 * <p>
 * Estimated cardinality is calculated by using the hyperloglog approximation
 * technique.
 * <p>
 * Percentiles and percentile_ranks are approximate and are calculated using
 * the t-digest algorithm. They must include the desired
 * percentile/percentile_rank. To compute multiple percentiles each value must
 * be specified separately (i.e. 'percentile(75.0),percentile(99.0),percentile_
 * rank(1234.56),percentile_rank(-5)').
 * <p>
 * The weighted average statistic requires a weight_attribute to be specified
 * in {@code options}. The weighted average is then defined as the sum of the
 * products of {@code column_name} times the weight attribute divided by the
 * sum of the weight attribute.
 * <p>
 * The response includes a list of the statistics requested along with the
 * count of the number of items in the given set.
 *
 * @param {String} table_name  Name of the table on which the statistics
 *                             operation will be performed.
 * @param {String} column_name  Name of the column for which the statistics are
 *                              to be calculated.
 * @param {String} stats  Comma separated list of the statistics to calculate,
 *                        e.g. "sum,mean".
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics = function(table_name, column_name, stats, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics(table_name, column_name, stats, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        stats: stats,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/statistics", actual_request, callback);
};

/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in
 * {@code options}. The weighted average is then defined as the sum of the
 * products of the value column times the weight column divided by the sum of
 * the weight column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of (max-
 * min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, {@code options} bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics_by_range_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics_by_range_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        select_expression: (request.select_expression !== undefined && request.select_expression !== null) ? request.select_expression : "",
        column_name: request.column_name,
        value_column_name: request.value_column_name,
        stats: request.stats,
        start: request.start,
        end: request.end,
        interval: request.interval,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/statistics/byrange", actual_request, callback);
};

/**
 * Divides the given set into bins and calculates statistics of the values of a
 * value-column in each bin.  The bins are based on the values of a given
 * binning-column.  The statistics that may be requested are mean, stdv
 * (standard deviation), variance, skew, kurtosis, sum, min, max, first, last
 * and weighted average. In addition to the requested statistics the count of
 * total samples in each bin is returned. This counts vector is just the
 * histogram of the column used to divide the set members into bins. The
 * weighted average statistic requires a weight_column to be specified in
 * {@code options}. The weighted average is then defined as the sum of the
 * products of the value column times the weight column divided by the sum of
 * the weight column.
 * <p>
 * There are two methods for binning the set members. In the first, which can
 * be used for numeric valued binning-columns, a min, max and interval are
 * specified. The number of bins, nbins, is the integer upper bound of (max-
 * min)/interval. Values that fall in the range
 * [min+n\*interval,min+(n+1)\*interval) are placed in the nth bin where n
 * ranges from 0..nbin-2. The final bin is [min+(nbin-1)\*interval,max]. In the
 * second method, {@code options} bin_values specifies a list of binning column
 * values. Binning-columns whose value matches the nth member of the bin_values
 * list are placed in the nth bin. When a list is provided the binning-column
 * must be of type string or int.
 *
 * @param {String} table_name  Name of the table on which the ranged-statistics
 *                             operation will be performed.
 * @param {String} select_expression  For a non-empty expression statistics are
 *                                    calculated for those records for which
 *                                    the expression is true.
 * @param {String} column_name  Name of the binning-column used to divide the
 *                              set samples into bins.
 * @param {String} value_column_name  Name of the value-column for which
 *                                    statistics are to be computed.
 * @param {String} stats  A string of comma separated list of the statistics to
 *                        calculate, e.g. 'sum,mean'. Available statistics:
 *                        mean, stdv (standard deviation), variance, skew,
 *                        kurtosis, sum.
 * @param {Number} start  The lower bound of the binning-column.
 * @param {Number} end  The upper bound of the binning-column.
 * @param {Number} interval  The interval of a bin. Set members fall into bin i
 *                           if the binning-column falls in the range
 *                           [start+interval``*``i, start+interval``*``(i+1)).
 * @param {Object} options  Map of optional parameters:
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_statistics_by_range = function(table_name, select_expression, column_name, value_column_name, stats, start, end, interval, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_statistics_by_range(table_name, select_expression, column_name, value_column_name, stats, start, end, interval, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        select_expression: (select_expression !== undefined && select_expression !== null) ? select_expression : "",
        column_name: column_name,
        value_column_name: value_column_name,
        stats: stats,
        start: start,
        end: end,
        interval: interval,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/statistics/byrange", actual_request, callback);
};

/**
 * Returns all the unique values from a particular column (specified by {@code
 * column_name}) of a particular table (specified by {@code table_name}). If
 * {@code column_name} is a numeric column the values will be in {@code
 * binary_encoded_response}. Otherwise if {@code column_name} is a string
 * column the values will be in {@code json_encoded_response}.  {@code offset}
 * and {@code limit} are used to page through the results if there are large
 * numbers of unique values. To get the first 10 unique values sorted in
 * descending order {@code options} would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_unique_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_unique_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_name: request.column_name,
        offset: request.offset,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 10000,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/aggregate/unique", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Returns all the unique values from a particular column (specified by {@code
 * column_name}) of a particular table (specified by {@code table_name}). If
 * {@code column_name} is a numeric column the values will be in {@code
 * binary_encoded_response}. Otherwise if {@code column_name} is a string
 * column the values will be in {@code json_encoded_response}.  {@code offset}
 * and {@code limit} are used to page through the results if there are large
 * numbers of unique values. To get the first 10 unique values sorted in
 * descending order {@code options} would be::
 * <p>
 * {"limit":"10","sort_order":"descending"}.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 *
 * @param {String} table_name  Name of the table on which the operation will be
 *                             performed. Must be a valid table in GPUdb.
 * @param {String} column_name  Name of the column or an expression containing
 *                              one or more column names on which the unique
 *                              function would be applied.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned. Or END_OF_SET (-9999) to
 *                        indicate that the max number of results should be
 *                        returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.aggregate_unique = function(table_name, column_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.aggregate_unique(table_name, column_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_name: column_name,
        offset: offset,
        limit: (limit !== undefined && limit !== null) ? limit : 10000,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/aggregate/unique", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * The alter_system_properties endpoint is primarily used to simplify the
 * testing of gpudb and is not expected to be used during normal execution.
 * Commands are given through the properties_update_map whose keys are commands
 * and values are strings representing integer values (for example '8000') or
 * boolean values ('true' or 'false').
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_system_properties_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_system_properties_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        property_updates_map: request.property_updates_map,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/system/properties", actual_request, callback);
};

/**
 * The alter_system_properties endpoint is primarily used to simplify the
 * testing of gpudb and is not expected to be used during normal execution.
 * Commands are given through the properties_update_map whose keys are commands
 * and values are strings representing integer values (for example '8000') or
 * boolean values ('true' or 'false').
 *
 * @param {Object} property_updates_map  Map containing the properties of the
 *                                       system to be updated. Error if empty.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_system_properties = function(property_updates_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_system_properties(property_updates_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        property_updates_map: property_updates_map,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/system/properties", actual_request, callback);
};

/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Cereating or deleting an index on a particular column. This can speed
 * up certain search queries (such as /get/records, /delete/records,
 * /update/records) when using expressions containing equality or relational
 * operators on indexed columns. This only applies to child tables.
 * <p>
 *      Making a table protected or not. Protected tables need the admin
 * password to be sent in a /clear/table to delete the table. This can be
 * applied to child tables or collections or views.
 * <p>
 *      Setting the ttl (time-to-live). This can be applied to child tables or
 * collections or views.
 * <p>
 *      Allowing homogeneous child tables. This only applies to collections.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        action: request.action,
        value: request.value,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/table", actual_request, callback);
};

/**
 * Apply various modifications to a table or collection. Available
 * modifications include:
 * <p>
 *      Cereating or deleting an index on a particular column. This can speed
 * up certain search queries (such as /get/records, /delete/records,
 * /update/records) when using expressions containing equality or relational
 * operators on indexed columns. This only applies to child tables.
 * <p>
 *      Making a table protected or not. Protected tables need the admin
 * password to be sent in a /clear/table to delete the table. This can be
 * applied to child tables or collections or views.
 * <p>
 *      Setting the ttl (time-to-live). This can be applied to child tables or
 * collections or views.
 * <p>
 *      Allowing homogeneous child tables. This only applies to collections.
 *
 * @param {String} table_name  Table on which the operation will be performed.
 *                             Must be a valid table or collection in GPUdb.
 * @param {String} action  Modification operation to be applied to the table or
 *                         collection
 * @param {String} value  The value of the modification. May be a column name,
 *                        'true' or 'false', or a time-to-live depending on
 *                        {@code action}.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table = function(table_name, action, value, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table(table_name, action, value, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        action: action,
        value: value,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/table", actual_request, callback);
};

/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_metadata_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_metadata_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        metadata_map: request.metadata_map,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/alter/table/metadata", actual_request, callback);
};

/**
 * Updates (adds or changes) metadata for tables. The metadata key and values
 * must both be strings. This is an easy way to annotate whole tables rather
 * than single records within tables.  Some examples of metadata are owner of
 * the table, table creation timestamp etc.
 *
 * @param {String[]} table_names  Names of the tables whose metadata will be
 *                                updated. All specified tables must exist in
 *                                GPUdb, or GPUdb will return an error.
 * @param {Object} metadata_map  A map which contains the metadata of the
 *                               tables that are to be updated. Note that only
 *                               one map is provided for all the tables; so the
 *                               change will be applied to every table. If the
 *                               provided map is empty, then all existing
 *                               metadata for the table(s) will be cleared.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.alter_table_metadata = function(table_names, metadata_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.alter_table_metadata(table_names, metadata_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        metadata_map: metadata_map,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/alter/table/metadata", actual_request, callback);
};

/**
 * Clears (drops) one or all tables in the GPUdb cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared. For protected tables, this function
 * requires an administrator password without which the operation will fail.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: (request.table_name !== undefined && request.table_name !== null) ? request.table_name : "",
        authorization: (request.authorization !== undefined && request.authorization !== null) ? request.authorization : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/clear/table", actual_request, callback);
};

/**
 * Clears (drops) one or all tables in the GPUdb cluster. The operation is
 * synchronous meaning that the table will be cleared before the function
 * returns. The response payload returns the status of the operation along with
 * the name of the table that was cleared. For protected tables, this function
 * requires an administrator password without which the operation will fail.
 *
 * @param {String} table_name  Name of the table to be cleared. Must be an
 *                             existing GPUdb table. Empty string clears all
 *                             available tables in GPUdb.
 * @param {String} authorization  Administrator password needed for clearing
 *                                protected tables. For unprotected tables the
 *                                string can be left blank.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table = function(table_name, authorization, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table(table_name, authorization, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: (table_name !== undefined && table_name !== null) ? table_name : "",
        authorization: (authorization !== undefined && authorization !== null) ? authorization : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/clear/table", actual_request, callback);
};

/**
 * Deactivates a table monitor previously created with /create/tablemonitor.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table_monitor_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table_monitor_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        topic_id: request.topic_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/clear/tablemonitor", actual_request, callback);
};

/**
 * Deactivates a table monitor previously created with /create/tablemonitor.
 *
 * @param {String} topic_id  The topic ID returned by /create/tablemonitor.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_table_monitor = function(topic_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_table_monitor(topic_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        topic_id: topic_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/clear/tablemonitor", actual_request, callback);
};

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_trigger_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_trigger_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_id: request.trigger_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/clear/trigger", actual_request, callback);
};

/**
 * Clears or cancels the trigger identified by the specified handle. The output
 * returns the handle of the trigger cleared as well as indicating success or
 * failure of the trigger deactivation.
 *
 * @param {String} trigger_id  ID for the trigger to be deactivated.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.clear_trigger = function(trigger_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.clear_trigger(trigger_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_id: trigger_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/clear/trigger", actual_request, callback);
};

/**
 * Creates a joint_table which is a list of tables and aliases for those
 * tables.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_join_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_join_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        join_table_name: request.join_table_name,
        table_names: request.table_names,
        aliases: request.aliases,
        expression: (request.expression !== undefined && request.expression !== null) ? request.expression : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/jointable", actual_request, callback);
};

/**
 * Creates a joint_table which is a list of tables and aliases for those
 * tables.
 *
 * @param {String} join_table_name  Name of the join_table to be created. Must
 *                                  not be the name of a currently existing
 *                                  GPUdb table or join_table. Cannot be an
 *                                  empty string.
 * @param {String[]} table_names  The list of table names making up the joined
 *                                set.  Corresponds to SQL statement from
 *                                clause
 * @param {String[]} aliases  The list of aliases for each of the corresponding
 *                            tables.
 * @param {String} expression  An optional expression GPUdb uses to filter the
 *                             join-table being created.  Corresponds to SQL
 *                             select statement where clause. For details see
 *                             <a href="../../concepts/index.html#expressions"
 *                             target="_top">concepts</a>.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_join_table = function(join_table_name, table_names, aliases, expression, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_join_table(join_table_name, table_names, aliases, expression, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        join_table_name: join_table_name,
        table_names: table_names,
        aliases: aliases,
        expression: (expression !== undefined && expression !== null) ? expression : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/jointable", actual_request, callback);
};

/**
 * Creates a new table or collection in GPUdb. If a new table is being created
 * then type of the table is given by {@code type_id} which must the be the
 * type id of a currently registered type (i.e. one created via /create/type).
 * The table will be created inside a collection if the option
 * *collection_name* is specified. If that collection does not already exist
 * then it will be created. To create a new, empty collection specify the
 * collection name in {@code table_name}, leave {@code type_id} blank, and set
 * the *is_collection* option to 'true'.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        type_id: request.type_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/table", actual_request, callback);
};

/**
 * Creates a new table or collection in GPUdb. If a new table is being created
 * then type of the table is given by {@code type_id} which must the be the
 * type id of a currently registered type (i.e. one created via /create/type).
 * The table will be created inside a collection if the option
 * *collection_name* is specified. If that collection does not already exist
 * then it will be created. To create a new, empty collection specify the
 * collection name in {@code table_name}, leave {@code type_id} blank, and set
 * the *is_collection* option to 'true'.
 *
 * @param {String} table_name  Name of the table to be created. Must not be the
 *                             name of a currently existing GPUdb table of a
 *                             different type.  Error for requests with
 *                             existing table of the same name and type id may
 *                             be suppressed by using the {@code
 *                             no_error_if_exists} option.  Cannot be an empty
 *                             string.  Valid characters are 'A-Za-z0-9_-(){}[]
 *                             .:' (excluding the single quote), with the first
 *                             character being one of 'A-Za-z0-9_'.  The
 *                             maximum length is 256 characters.
 * @param {String} type_id  ID of a currently registered type in GPUdb. All
 *                          objects added to the newly created table will be of
 *                          this type.  Must be an empty string if the
 *                          *is_collection* is 'true'.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table = function(table_name, type_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table(table_name, type_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        type_id: type_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/table", actual_request, callback);
};

/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by {@code table_name}) and forwards copies to subscribers
 * via ZMQ. After this call completes, subscribe to the returned {@code
 * topic_id} on the GPUdb ZMQ table monitor port (default 9002). Each time an
 * insert operation on the table completes, a multipart message is published
 * for that topic; the first part contains only the topic ID, and each
 * subsequent part contains one binary-encoded Avro object that was inserted.
 * The monitor will continue to run (regardless of whether or not there are any
 * subscribers) until deactivated with /clear/tablemonitor.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_monitor_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_monitor_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/tablemonitor", actual_request, callback);
};

/**
 * Creates a monitor that watches for new records inserted into a particular
 * table (identified by {@code table_name}) and forwards copies to subscribers
 * via ZMQ. After this call completes, subscribe to the returned {@code
 * topic_id} on the GPUdb ZMQ table monitor port (default 9002). Each time an
 * insert operation on the table completes, a multipart message is published
 * for that topic; the first part contains only the topic ID, and each
 * subsequent part contains one binary-encoded Avro object that was inserted.
 * The monitor will continue to run (regardless of whether or not there are any
 * subscribers) until deactivated with /clear/tablemonitor.
 *
 * @param {String} table_name  Name of the table to monitor. Must not refer to
 *                             a collection.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_table_monitor = function(table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_table_monitor(table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/tablemonitor", actual_request, callback);
};

/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of
 * /create/trigger/byrange.) Once the trigger has been activated, any record
 * added to the listed tables(s) via /insert/records with the chosen columns'
 * values falling within the specified region will trip the trigger. All such
 * records will be queued at GPUdb's trigger port-by default '9001' but can
 * also be obtained via /show/system/status-for any listening client to
 * collect. Active triggers can be cancelled by using the /clear/trigger
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_area_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_area_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request.request_id,
        table_names: request.table_names,
        x_column_name: request.x_column_name,
        x_vector: request.x_vector,
        y_column_name: request.y_column_name,
        y_vector: request.y_vector,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/trigger/byarea", actual_request, callback);
};

/**
 * Sets up an area trigger mechanism for two column_names for one or more
 * tables. (This function is essentially the two-dimensional version of
 * /create/trigger/byrange.) Once the trigger has been activated, any record
 * added to the listed tables(s) via /insert/records with the chosen columns'
 * values falling within the specified region will trip the trigger. All such
 * records will be queued at GPUdb's trigger port-by default '9001' but can
 * also be obtained via /show/system/status-for any listening client to
 * collect. Active triggers can be cancelled by using the /clear/trigger
 * endpoint or by clearing all relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 *
 * @param {String} request_id  ID for the trigger to be activated.
 * @param {String[]} table_names  Names of the tables on which the trigger will
 *                                be activated and maintained.
 * @param {String} x_column_name  Name of a numeric column on which the trigger
 *                                is activated. Usually 'x' for geospatial data
 *                                points.
 * @param {Number[]} x_vector  The respective coordinate values for the region
 *                             on which the trigger is activated. This usually
 *                             translates to the x-coordinates of a geospatial
 *                             region.
 * @param {String} y_column_name  Name of a second numeric column on which the
 *                                trigger is activated. Usually 'y' for
 *                                geospatial data points.
 * @param {Number[]} y_vector  The respective coordinate values for the region
 *                             on which the trigger is activated. This usually
 *                             translates to the y-coordinates of a geospatial
 *                             region. Must be the same length as xvals.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_area = function(request_id, table_names, x_column_name, x_vector, y_column_name, y_vector, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_area(request_id, table_names, x_column_name, x_vector, y_column_name, y_vector, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request_id,
        table_names: table_names,
        x_column_name: x_column_name,
        x_vector: x_vector,
        y_column_name: y_column_name,
        y_vector: y_vector,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/trigger/byarea", actual_request, callback);
};

/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via /insert/records with the chosen column_name's value falling
 * within the specified range will trip the trigger. All such records will be
 * queued at GPUdb's trigger port-by default '9001' but can also be obtained
 * via /show/system/status-for any listening client to collect. Active triggers
 * can be cancelled by using the /clear/trigger endpoint or by clearing all
 * relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_range_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_range_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request.request_id,
        table_names: request.table_names,
        column_name: request.column_name,
        min: request.min,
        max: request.max,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/trigger/byrange", actual_request, callback);
};

/**
 * Sets up a simple range trigger for a column_name for one or more tables.
 * Once the trigger has been activated, any record added to the listed
 * tables(s) via /insert/records with the chosen column_name's value falling
 * within the specified range will trip the trigger. All such records will be
 * queued at GPUdb's trigger port-by default '9001' but can also be obtained
 * via /show/system/status-for any listening client to collect. Active triggers
 * can be cancelled by using the /clear/trigger endpoint or by clearing all
 * relevant tables.
 * <p>
 * The output returns the trigger handle as well as indicating success or
 * failure of the trigger activation.
 *
 * @param {String} request_id  ID for the trigger request.
 * @param {String[]} table_names  Tables on which the trigger will be active.
 * @param {String} column_name  Name of a numeric column_name on which the
 *                              trigger is activated.
 * @param {Number} min  The lower bound (inclusive) for the trigger range.
 * @param {Number} max  The upper bound (inclusive) for the trigger range.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_trigger_by_range = function(request_id, table_names, column_name, min, max, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_trigger_by_range(request_id, table_names, column_name, min, max, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        request_id: request_id,
        table_names: table_names,
        column_name: column_name,
        min: min,
        max: max,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/trigger/byrange", actual_request, callback);
};

/**
 * Creates a new type in GPUdb describing the layout or schema of a table. The
 * type definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are {@code
 * data} and {@code store_only}.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified
 * then GPUdb enforces a uniqueness constraint in that only a single object can
 * exist with a given primary key. When /insert/records data into a table with
 * a primary key, depending on the parameters in the request, incoming objects
 * with primary keys that match existing objects will either overwrite (i.e.
 * update) the existing object or will be skipped and not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_type_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_type_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_definition: request.type_definition,
        label: request.label,
        properties: (request.properties !== undefined && request.properties !== null) ? request.properties : {},
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/create/type", actual_request, callback);
};

/**
 * Creates a new type in GPUdb describing the layout or schema of a table. The
 * type definition is a JSON string describing the fields (i.e. columns) of the
 * type. Each field consists of a name and a data type. Supported data types
 * are: double, float, int, long, string, and bytes. In addition one or more
 * properties can be specified for each column which customize the memory usage
 * and query availability of that column.  Note that some properties are
 * mutually exclusive--i.e. they cannot be specified for any given column
 * simultaneously.  One example of mutually exclusive properties are {@code
 * data} and {@code store_only}.
 * <p>
 * To set a *primary key* on one or more columns include the property
 * 'primary_key' on the desired column_names. If a primary key is specified
 * then GPUdb enforces a uniqueness constraint in that only a single object can
 * exist with a given primary key. When /insert/records data into a table with
 * a primary key, depending on the parameters in the request, incoming objects
 * with primary keys that match existing objects will either overwrite (i.e.
 * update) the existing object or will be skipped and not added into the set.
 * <p>
 * Example of a type definition with some of the parameters::
 * <p>
 *         {"type":"record",
 *         "name":"point",
 *         "fields":[{"name":"msg_id","type":"string"},
 *                         {"name":"x","type":"double"},
 *                         {"name":"y","type":"double"},
 *                         {"name":"TIMESTAMP","type":"double"},
 *                         {"name":"source","type":"string"},
 *                         {"name":"group_id","type":"string"},
 *                         {"name":"OBJECT_ID","type":"string"}]
 *         }
 * <p>
 * Properties::
 * <p>
 *         {"group_id":["store_only"],
 *         "msg_id":["store_only","text_search"]
 *         }
 *
 * @param {String} type_definition  a JSON string describing the columns of the
 *                                  type to be registered.
 * @param {String} label  A user-defined description string which can be used
 *                        to differentiate between tables and types with
 *                        otherwise identical schemas.
 * @param {Object} properties  Each key-value pair specifies the properties to
 *                             use for a given column where the key is the
 *                             column name.  All keys used must be relevant
 *                             column names for the given table.  Specifying
 *                             any property overrides the default properties
 *                             for that column (which is based on the column's
 *                             data type).
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.create_type = function(type_definition, label, properties, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.create_type(type_definition, label, properties, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_definition: type_definition,
        label: label,
        properties: (properties !== undefined && properties !== null) ? properties : {},
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/create/type", actual_request, callback);
};

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  {@code expressions}
 * (matching multiple records) or a single record identified by {@code
 * record_id} optiona.  Note that the two selection criteria are mutually
 * exclusive.  This operation cannot be run on a collection or a view.  The
 * operation is synchronous meaning that a response will not be available until
 * the request is completely processed and all the matching records are
 * deleted.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        expressions: request.expressions,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/delete/records", actual_request, callback);
};

/**
 * Deletes record(s) matching the provided criteria from the given table. The
 * record selection criteria can either be one or more  {@code expressions}
 * (matching multiple records) or a single record identified by {@code
 * record_id} optiona.  Note that the two selection criteria are mutually
 * exclusive.  This operation cannot be run on a collection or a view.  The
 * operation is synchronous meaning that a response will not be available until
 * the request is completely processed and all the matching records are
 * deleted.
 *
 * @param {String} table_name  Name of the table from which to delete records.
 *                             The set must be a currently existing table and
 *                             not a collection or a view.
 * @param {String[]} expressions  A list of the actual predicates, one for each
 *                                select; format should follow the guidelines
 *                                provided /filter. Specifying one or more
 *                                {@code expressions} is mutually exclusive to
 *                                specifying {@code record_id} in the {@code
 *                                options}.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.delete_records = function(table_name, expressions, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.delete_records(table_name, expressions, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        expressions: expressions,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/delete/records", actual_request, callback);
};

/**
 * Executes a proc in the GPUdb Node.js proc server.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.execute_proc_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.execute_proc_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: request.name,
        params: request.params,
        bin_params: request.bin_params,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/execute/proc", actual_request, callback);
};

/**
 * Executes a proc in the GPUdb Node.js proc server.
 *
 * @param {String} name  Name of the proc to execute.
 * @param {Object} params  A map containing string parameters to pass to the
 *                         proc. Each key/value pair specifies the name of a
 *                         parameter and its value.
 * @param {Object} bin_params  A map containing binary parameters to pass to
 *                             the proc. Each key/value pair specifies the name
 *                             of a parameter and its value.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.execute_proc = function(name, params, bin_params, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.execute_proc(name, params, bin_params, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        name: name,
        params: params,
        bin_params: bin_params,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/execute/proc", actual_request, callback);
};

/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given {@code view_name}.
 * <p>
 * For details see <a href="../../concepts/index.html#expressions"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        expression: request.expression,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter", actual_request, callback);
};

/**
 * Filters data based on the specified expression.  The results are stored in a
 * result set with the given {@code view_name}.
 * <p>
 * For details see <a href="../../concepts/index.html#expressions"
 * target="_top">concepts</a>.
 * <p>
 * The response message contains the number of points for which the expression
 * evaluated to be true, which is equivalent to the size of the result view.
 *
 * @param {String} table_name  Name of the table to filter.  This may be the ID
 *                             of a collection, table or a result set (for
 *                             chaining queries).  Collections may be filtered
 *                             only if all tables within the collection have
 *                             the same type ID.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Must not be an
 *                            already existing collection, table or view .
 * @param {String} expression  The select expression GPUdb uses to filter the
 *                             specified table.  For details see <a
 *                             href="../../concepts/index.html#expressions"
 *                             target="_top">concepts</a>.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter = function(table_name, view_name, expression, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter(table_name, view_name, expression, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        expression: expression,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter", actual_request, callback);
};

/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous meaning that GPUdb will not
 * return the request until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name {@code view_name} passed in as part of the input.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_area_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_area_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        x_column_name: request.x_column_name,
        x_vector: request.x_vector,
        y_column_name: request.y_column_name,
        y_vector: request.y_vector,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byarea", actual_request, callback);
};

/**
 * Calculates which objects from a table are within a named area of interest
 * (NAI/polygon). The operation is synchronous meaning that GPUdb will not
 * return the request until all the matching objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input NAI restriction specification is
 * created with the name {@code view_name} passed in as part of the input.
 *
 * @param {String} table_name  Name of the table to filter.  This may be the
 *                             name of a collection, a table or a view (when
 *                             chaining queries).  Collections may be filtered
 *                             only if all tables within the collection have
 *                             the same type ID.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Must not be an
 *                            already existing collection, table or view.
 * @param {String} x_column_name  Name of the column containing the x values to
 *                                be filtered.
 * @param {Number[]} x_vector  List of x coordinates of the vertices of the
 *                             polygon representing the area to be filtered.
 * @param {String} y_column_name  Name of the column containing the y values to
 *                                be filtered.
 * @param {Number[]} y_vector  List of y coordinates of the vertices of the
 *                             polygon representing the area to be filtered.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_area = function(table_name, view_name, x_column_name, x_vector, y_column_name, y_vector, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_area(table_name, view_name, x_column_name, x_vector, y_column_name, y_vector, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        x_column_name: x_column_name,
        x_vector: x_vector,
        y_column_name: y_column_name,
        y_vector: y_vector,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byarea", actual_request, callback);
};

/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous meaning that GPUdb will not return the request
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a {@code view_name} is
 * passed in as part of the input payload.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_box_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_box_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        x_column_name: request.x_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        y_column_name: request.y_column_name,
        min_y: request.min_y,
        max_y: request.max_y,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bybox", actual_request, callback);
};

/**
 * Calculates how many objects within the given table lie in a rectangular box.
 * The operation is synchronous meaning that GPUdb will not return the request
 * until all the objects are fully available. The response payload provides the
 * count of the resulting set. A new resultant set which satisfies the input
 * NAI restriction specification is also created when a {@code view_name} is
 * passed in as part of the input payload.
 *
 * @param {String} table_name  Name of the table on which the bounding box
 *                             operation will be performed. Must be a valid
 *                             table in GPUdb.
 * @param {String} view_name  Optional name of the result view that will be
 *                            created containing the results of the query. Must
 *                            not be an already existing collection, table or
 *                            view in GPUdb.
 * @param {String} x_column_name  Name of the column on which to perform the
 *                                bounding box query. If the table's data type
 *                                is not a shape type, must be a valid numeric
 *                                column.
 * @param {Number} min_x  Lower bound for the column chosen by {@code
 *                        x_column_name}.  Must be less than or equal to {@code
 *                        max_x}.
 * @param {Number} max_x  Upper bound for {@code x_column_name}.  Must be
 *                        greater than or equal to {@code min_x}.
 * @param {String} y_column_name  Name of a column on which to perform the
 *                                bounding box query. If the table's data type
 *                                is not a shape type, must be a valid numeric
 *                                column.
 * @param {Number} min_y  Lower bound for {@code y_column_name}. Must be less
 *                        than or equal to {@code max_y}.
 * @param {Number} max_y  Upper bound for {@code y_column_name}. Must be
 *                        greater than or equal to {@code min_y}.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_box = function(table_name, view_name, x_column_name, min_x, max_x, y_column_name, min_y, max_y, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_box(table_name, view_name, x_column_name, min_x, max_x, y_column_name, min_y, max_y, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        x_column_name: x_column_name,
        min_x: min_x,
        max_x: max_x,
        y_column_name: y_column_name,
        min_y: min_y,
        max_y: max_y,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bybox", actual_request, callback);
};

/**
 * Applies a geometry filter against a spatial column in a given table,
 * collection or view. The filtering geometry is provided by {@code input_wkt}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_geometry_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_geometry_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        input_wkt: (request.input_wkt !== undefined && request.input_wkt !== null) ? request.input_wkt : "",
        operation: request.operation,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bygeometry", actual_request, callback);
};

/**
 * Applies a geometry filter against a spatial column in a given table,
 * collection or view. The filtering geometry is provided by {@code input_wkt}.
 *
 * @param {String} table_name  Name of the table on which the filter by spatial
 *                             operation will be performed.  Must be an
 *                             existing table, collection or view in GPUdb.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Must not be an
 *                            already existing collection, table or view.
 * @param {String} column_name  Name of the column to be used in the filter.
 *                              Must be a spatial column. Typically this will
 *                              be 'WKT'
 * @param {String} input_wkt  A geometry in WKT format that will be used to
 *                            filter the objects in {@code table_name}
 * @param {String} operation  The geometric filtering operation to perform
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_geometry = function(table_name, view_name, column_name, input_wkt, operation, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_geometry(table_name, view_name, column_name, input_wkt, operation, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        input_wkt: (input_wkt !== undefined && input_wkt !== null) ? input_wkt : "",
        operation: operation,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bygeometry", actual_request, callback);
};

/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous meaning that GPUdb will
 * not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input filter specification is also created if
 * a {@code view_name} is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_list_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_list_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_values_map: request.column_values_map,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bylist", actual_request, callback);
};

/**
 * Calculates which records from a table have values in the given list for the
 * corresponding column. The operation is synchronous meaning that GPUdb will
 * not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new resultant
 * set (view) which satisfies the input filter specification is also created if
 * a {@code view_name} is passed in as part of the request.
 * <p>
 * For example, if a type definition has the columns 'x' and 'y', then a filter
 * by list query with the column map {"x":["10.1", "2.3"], "y":["0.0", "-31.5",
 * "42.0"]} will return the count of all data points whose x and y values match
 * one of the values in the respective x- and y-lists. If the filter_mode
 * option is set to 'not_in_list' then the filter will match all items that are
 * not in the provided list(s).
 *
 * @param {String} table_name  Name of the table to filter.  This may be the ID
 *                             of a collection, table or a result set (for
 *                             chaining queries).  Collections may be filtered
 *                             only if all tables within the collection have
 *                             the same type ID.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Must not be an
 *                            already existing collection, table or view.
 * @param {Object} column_values_map  List of values for the corresponding
 *                                    column in the table
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_list = function(table_name, view_name, column_values_map, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_list(table_name, view_name, column_values_map, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_values_map: column_values_map,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bylist", actual_request, callback);
};

/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous
 * meaning that GPUdb will not return a response until all the objects are
 * fully available. The response payload provides the count of the resulting
 * set. A new resultant set (view) which satisfies the input circular NAI
 * restriction specification is also created if a {@code view_name} is passed
 * in as part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_radius_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_radius_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        x_column_name: request.x_column_name,
        x_center: request.x_center,
        y_column_name: request.y_column_name,
        y_center: request.y_center,
        radius: request.radius,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byradius", actual_request, callback);
};

/**
 * Calculates which objects from a table lie within a circle with the given
 * radius and center point (i.e. circular NAI). The operation is synchronous
 * meaning that GPUdb will not return a response until all the objects are
 * fully available. The response payload provides the count of the resulting
 * set. A new resultant set (view) which satisfies the input circular NAI
 * restriction specification is also created if a {@code view_name} is passed
 * in as part of the request.
 * <p>
 * For track data, all track points that lie within the circle plus one point
 * on either side of the circle (if the track goes beyond the circle) will be
 * included in the result. For shapes, e.g. polygons, all polygons that
 * intersect the circle will be included (even if none of the points of the
 * polygon fall within the circle).
 *
 * @param {String} table_name  Name of the table on which the filter by radius
 *                             operation will be performed.  Must be an
 *                             existing table in GPUdb.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Must not be an
 *                            already existing collection, table or view.
 * @param {String} x_column_name  Name of the column to be used for the
 *                                x-coordinate (the longitude) of the center.
 * @param {Number} x_center  Value of the longitude of the center. Must be
 *                           within [-180.0, 180.0].
 * @param {String} y_column_name  Name of the column to be used for the y
 *                                -coordinate-the latitude-of the center.
 * @param {Number} y_center  Value of the latitude of the center. Must be
 *                           within [-90.0, 90.0].
 * @param {Number} radius  The radius of the circle within which the search
 *                         will be performed. Must be a non-zero positive
 *                         value. It is in meters; so, for example, a value of
 *                         '42000' means 42 km.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_radius = function(table_name, view_name, x_column_name, x_center, y_column_name, y_center, radius, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_radius(table_name, view_name, x_column_name, x_center, y_column_name, y_center, radius, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        x_column_name: x_column_name,
        x_center: x_center,
        y_column_name: y_column_name,
        y_center: y_center,
        radius: radius,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byradius", actual_request, callback);
};

/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by {@code table_name} is added
 * to the view {@code view_name} if its column is within [{@code lower_bound},
 * {@code upper_bound}] (inclusive). The operation is synchronous. The response
 * provides a count of the number of objects which passed the bound filter.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_range_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_range_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        lower_bound: request.lower_bound,
        upper_bound: request.upper_bound,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byrange", actual_request, callback);
};

/**
 * Calculates which objects from a table have a column that is within the given
 * bounds. An object from the table identified by {@code table_name} is added
 * to the view {@code view_name} if its column is within [{@code lower_bound},
 * {@code upper_bound}] (inclusive). The operation is synchronous. The response
 * provides a count of the number of objects which passed the bound filter.
 * <p>
 * For track objects, the count reflects how many points fall within the given
 * bounds (which may not include all the track points of any given track).
 *
 * @param {String} table_name  Name of the table on which the filter by range
 *                             operation will be performed.  Must be a valid
 *                             GPUdb table.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Must not be an
 *                            already existing collection, table or view.
 * @param {String} column_name  Name of a column or an expression of one or
 *                              more columns on which the operation would be
 *                              applied.
 * @param {Number} lower_bound  Value of the lower bound (inclusive).
 * @param {Number} upper_bound  Value of the upper bound (inclusive).
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_range = function(table_name, view_name, column_name, lower_bound, upper_bound, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_range(table_name, view_name, column_name, lower_bound, upper_bound, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        lower_bound: lower_bound,
        upper_bound: upper_bound,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byrange", actual_request, callback);
};

/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and temporal-
 * of all points of the given track. Additionally, the user can specify another
 * track to see if the two intersect (or go close to each other within the
 * specified ranges). The user also has the flexibility of using different
 * metrics for the spatial distance calculation: Euclidean (flat geometry) or
 * Great Circle (spherical geometry to approximate the Earth's surface
 * distances). The filtered points are stored in a newly created result set.
 * The return value of the function is the number of points in the resultant
 * set (view).
 * <p>
 * This operation is synchronous meaning that GPUdb will not return a response
 * until all the objects are fully available.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_series_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_series_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        track_id: request.track_id,
        target_track_ids: request.target_track_ids,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byseries", actual_request, callback);
};

/**
 * Filters objects matching all points of the given track (works only on track
 * type data).  It allows users to specify a particular track to find all other
 * points in the table that fall within specified ranges-spatial and temporal-
 * of all points of the given track. Additionally, the user can specify another
 * track to see if the two intersect (or go close to each other within the
 * specified ranges). The user also has the flexibility of using different
 * metrics for the spatial distance calculation: Euclidean (flat geometry) or
 * Great Circle (spherical geometry to approximate the Earth's surface
 * distances). The filtered points are stored in a newly created result set.
 * The return value of the function is the number of points in the resultant
 * set (view).
 * <p>
 * This operation is synchronous meaning that GPUdb will not return a response
 * until all the objects are fully available.
 *
 * @param {String} table_name  Name of the table on which the filter by track
 *                             operation will be performed. Must be a currently
 *                             existing table with track semantic type.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Must not be an
 *                            already existing collection, table or view.
 * @param {String} track_id  The ID of the track which will act as the
 *                           filtering points. Must be an existing track within
 *                           the given table.
 * @param {String[]} target_track_ids  Up to one track ID to intersect with the
 *                                     "filter" track. If any provided, it must
 *                                     be an valid track ID within the given
 *                                     set.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_series = function(table_name, view_name, track_id, target_track_ids, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_series(table_name, view_name, track_id, target_track_ids, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        track_id: track_id,
        target_track_ids: target_track_ids,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byseries", actual_request, callback);
};

/**
 * Calculates which objects from a table, collection or view match a string
 * expression for the given string columns. The 'mode' may be:
 * <p>
 *     'search' for full text search query with wildcards and boolean
 * operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode, no
 * column can be specified in {@code column_names}; GPUdb will search through
 * all string columns of the table that have text search enabled. Also, the
 * first character of the regular expression cannot be a wildcard (* or ?).
 * <p>
 * * 'equals' for an exact whole-string match
 * * 'contains' for a partial substring match (not accelerated)
 * * 'starts_with' to find strings that start with the given expression (not
 * accelerated)
 * * 'regex' - to use a full regular expression search (not accelerated)
 * <p>
 * The options 'case_sensitive' can be used to modify the behavior for all
 * modes except 'search'
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_string_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_string_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        expression: request.expression,
        mode: request.mode,
        column_names: request.column_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bystring", actual_request, callback);
};

/**
 * Calculates which objects from a table, collection or view match a string
 * expression for the given string columns. The 'mode' may be:
 * <p>
 *     'search' for full text search query with wildcards and boolean
 * operators, e.g. '(bob* OR sue) AND NOT jane'. Note that for this mode, no
 * column can be specified in {@code column_names}; GPUdb will search through
 * all string columns of the table that have text search enabled. Also, the
 * first character of the regular expression cannot be a wildcard (* or ?).
 * <p>
 * * 'equals' for an exact whole-string match
 * * 'contains' for a partial substring match (not accelerated)
 * * 'starts_with' to find strings that start with the given expression (not
 * accelerated)
 * * 'regex' - to use a full regular expression search (not accelerated)
 * <p>
 * The options 'case_sensitive' can be used to modify the behavior for all
 * modes except 'search'
 *
 * @param {String} table_name  Name of the table on which the filter operation
 *                             will be performed.  Must be a valid GPUdb table,
 *                             collection or view.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Must not be an
 *                            already existing collection, table or view.
 * @param {String} expression  The expression with which to filter the table.
 * @param {String} mode  The string filtering mode to apply. See above for
 *                       details.
 * @param {String[]} column_names  List of columns on which to apply the
 *                                 filter. Ignored for 'search' mode.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_string = function(table_name, view_name, expression, mode, column_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_string(table_name, view_name, expression, mode, column_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        expression: expression,
        mode: mode,
        column_names: column_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bystring", actual_request, callback);
};

/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a {@code view_name} is specified, then the filtered objects will then be put
 * in a newly created view. The operation is synchronous, meaning that GPUdb
 * will not return until all objects are fully available in the result view.
 * The return value contains the count (i.e. the size) of the resulting view.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        column_name: request.column_name,
        source_table_name: request.source_table_name,
        source_table_column_name: request.source_table_column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/bytable", actual_request, callback);
};

/**
 * Filters objects in one table based on objects in another table. The user
 * must specify matching column types from the two tables (i.e. the target
 * table from which objects will be filtered and the source table based on
 * which the filter will be created); the column names need not be the same. If
 * a {@code view_name} is specified, then the filtered objects will then be put
 * in a newly created view. The operation is synchronous, meaning that GPUdb
 * will not return until all objects are fully available in the result view.
 * The return value contains the count (i.e. the size) of the resulting view.
 *
 * @param {String} table_name  Name of the table whose data will be filtered.
 *                             Must be an existing table in GPUdb.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Must not be an
 *                            already existing collection, table or view.
 * @param {String} column_name  Name of the column by whose value the data will
 *                              be filtered from the table designated by {@code
 *                              table_name}.
 * @param {String} source_table_name  Name of the table whose data will be
 *                                    compared against in the table called
 *                                    {@code table_name}. Must be an existing
 *                                    table in GPUdb.
 * @param {String} source_table_column_name  Name of the column in the {@code
 *                                           source_table_name} whose values
 *                                           will be used as the filter for
 *                                           table {@code table_name}. Must
 *                                           match the type of the {@code
 *                                           column_name}.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_table = function(table_name, view_name, column_name, source_table_name, source_table_column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_table(table_name, view_name, column_name, source_table_name, source_table_column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        column_name: column_name,
        source_table_name: source_table_name,
        source_table_column_name: source_table_column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/bytable", actual_request, callback);
};

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous meaning that GPUdb
 * will not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_value_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_value_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        is_string: request.is_string,
        value: (request.value !== undefined && request.value !== null) ? request.value : 0,
        value_str: (request.value_str !== undefined && request.value_str !== null) ? request.value_str : "",
        column_name: request.column_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/filter/byvalue", actual_request, callback);
};

/**
 * Calculates which objects from a table has a particular value for a
 * particular column. The input parameters provide a way to specify either a
 * String or a Double valued column and a desired value for the column on which
 * the filter is performed. The operation is synchronous meaning that GPUdb
 * will not return a response until all the objects are fully available. The
 * response payload provides the count of the resulting set. A new result view
 * which satisfies the input filter restriction specification is also created
 * with a view name passed in as part of the input payload.
 *
 * @param {String} table_name  Name of an existing GPUdb table on which to
 *                             perform the calculation.
 * @param {String} view_name  If provided, then this will be the name of the
 *                            view containing the results. Must not be an
 *                            already existing collection, table or view.
 * @param {Boolean} is_string  Indicates whether the value being searched for
 *                             is string or numeric.
 * @param {Number} value  The value to search for.
 * @param {String} value_str  The string value to search for.
 * @param {String} column_name  Name of a column or an expression of one or
 *                              more columns on which the filter by value would
 *                              be applied.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.filter_by_value = function(table_name, view_name, is_string, value, value_str, column_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.filter_by_value(table_name, view_name, is_string, value, value_str, column_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        is_string: is_string,
        value: (value !== undefined && value !== null) ? value : 0,
        value_str: (value_str !== undefined && value_str !== null) ? value_str : "",
        column_name: column_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/filter/byvalue", actual_request, callback);
};

/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the {@code offset} and
 * {@code limit} parameters. Note that when paging through a table, if the
 * table (or the underlying table in case of a view) is updated (records are
 * inserted, deleted or modified) the records retrieved may differ between
 * calls based on the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 10000,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/get/records", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves records from a given table, optionally filtered by an expression
 * and/or sorted by a column. This operation can only be performed on tables or
 * on homogeneous collection (collections whose children all have the same
 * type). Records can be returned encoded as binary or json.
 * <p>
 * This operation supports paging through the data via the {@code offset} and
 * {@code limit} parameters. Note that when paging through a table, if the
 * table (or the underlying table in case of a view) is updated (records are
 * inserted, deleted or modified) the records retrieved may differ between
 * calls based on the updates applied.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 *
 * @param {String} table_name  Name of the table from which the records will be
 *                             fetched. Must be a table, view or homogeneous
 *                             collection.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned. Or END_OF_SET (-9999) to
 *                        indicate that the max number of results should be
 *                        returned.
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records = function(table_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records(table_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : 10000,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/records", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_column_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_column_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        column_names: request.column_names,
        offset: request.offset,
        limit: request.limit,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/get/records/bycolumn", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * For a given table, retrieves the values of the given columns within a given
 * range. It returns maps of column name to the vector of values for each
 * supported data type (double, float, long, int and string). This operation
 * supports pagination feature, i.e. values that are retrieved are those
 * associated with the indices between the start (offset) and end value (offset
 * + limit) parameters (inclusive). If there are num_points values in the table
 * then each of the indices between 0 and num_points-1 retrieves a unique
 * value.
 * <p>
 * Note that when using the pagination feature, if the table (or the underlying
 * table in case of a view) is updated (records are inserted, deleted or
 * modified) the records or values retrieved may differ between calls
 * (discontiguous or overlap) based on the type of the update.
 * <p>
 * The response is returned as a dynamic schema. For details see: <a
 * href="../../concepts/index.html#dynamic-schemas" target="_top">dynamic
 * schemas documentation</a>.
 *
 * @param {String} table_name  Name of the table on which this operation will
 *                             be performed. The table cannot be a parent set.
 * @param {String[]} column_names  The list of column values to retrieve.
 *                                 Columns annotated as store only cannot be
 *                                 retrieved.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned (if not provided the default
 *                        is 10000). Or END_OF_column (-9999) to indicate that
 *                        the max number of results should be returned.
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_column = function(table_name, column_names, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_column(table_name, column_names, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        column_names: column_names,
        offset: offset,
        limit: limit,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/records/bycolumn", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.json_encoded_response);
            delete data.json_encoded_response;
        }

        callback(err, data);
    });
};

/**
 * Retrieves the complete series/track records from the given {@code
 * world_table_name} based on the partial track informaton contained in the
 * {@code table_name}.
 * <p>
 * This operation supports paging through the data via the {@code offset} and
 * {@code limit} parameters.
 * <p>
 * In contrast to /get/records this returns records grouped by series/track. So
 * if {@code offset} is 0 and {@code limit} is 5 this operation would return
 * the first 5 series/tracks in {@code table_name}. Each series/track will be
 * returned sorted by their TIMESTAMP column.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_series_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_series_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        world_table_name: request.world_table_name,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 10000,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/get/records/byseries", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.list_records_json);
            delete data.list_records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves the complete series/track records from the given {@code
 * world_table_name} based on the partial track informaton contained in the
 * {@code table_name}.
 * <p>
 * This operation supports paging through the data via the {@code offset} and
 * {@code limit} parameters.
 * <p>
 * In contrast to /get/records this returns records grouped by series/track. So
 * if {@code offset} is 0 and {@code limit} is 5 this operation would return
 * the first 5 series/tracks in {@code table_name}. Each series/track will be
 * returned sorted by their TIMESTAMP column.
 *
 * @param {String} table_name  Name of the collection/table/view for which
 *                             series/tracks will be fetched.
 * @param {String} world_table_name  Name of the table containing the complete
 *                                   series/track information to be returned
 *                                   for the tracks present in the {@code
 *                                   table_name}. Typically this is used when
 *                                   retrieving series/tracks from a view
 *                                   (which contains partial series/tracks) but
 *                                   the user wants to retrieve the entire
 *                                   original series/tracks. Can be blank.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         series/tracks to skip (useful for paging through the
 *                         results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        series/tracks to be returned. Or END_OF_SET (-9999)
 *                        to indicate that the max number of results should be
 *                        returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_by_series = function(table_name, world_table_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_by_series(table_name, world_table_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        world_table_name: world_table_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : 10000,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/records/byseries", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.list_records_json);
            delete data.list_records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as /delete/records.
 * <p>
 * This operation supports paging through the data via the {@code offset} and
 * {@code limit} parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_from_collection_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_from_collection_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        offset: (request.offset !== undefined && request.offset !== null) ? request.offset : 0,
        limit: (request.limit !== undefined && request.limit !== null) ? request.limit : 10000,
        encoding: (request.encoding !== undefined && request.encoding !== null) ? request.encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/get/records/fromcollection", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * Retrieves records from a collection. The operation can optionally return the
 * record IDs which can be used in certain queries such as /delete/records.
 * <p>
 * This operation supports paging through the data via the {@code offset} and
 * {@code limit} parameters.
 * <p>
 * Note that when using the Java API, it is not possible to retrieve records
 * from join tables using this operation.
 *
 * @param {String} table_name  Name of the collection or table from which
 *                             records are to be retrieved. Must be an existing
 *                             GPUdb collection or table.
 * @param {Number} offset  A positive integer indicating the number of initial
 *                         results to skip (this can be useful for paging
 *                         through the results).
 * @param {Number} limit  A positive integer indicating the maximum number of
 *                        results to be returned, or END_OF_SET (-9999) to
 *                        indicate that the max number of results should be
 *                        returned.
 * @param {Object} options
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.get_records_from_collection = function(table_name, offset, limit, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.get_records_from_collection(table_name, offset, limit, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        offset: (offset !== undefined && offset !== null) ? offset : 0,
        limit: (limit !== undefined && limit !== null) ? limit : 10000,
        encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/get/records/fromcollection", actual_request, function(err, data) {
        if (err === null) {
            data.data = GPUdb.decode(data.records_json);
            delete data.records_json;
        }

        callback(err, data);
    });
};

/**
 * Checks the existence of a table with the given name in GPUdb.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/table", actual_request, callback);
};

/**
 * Checks the existence of a table with the given name in GPUdb.
 *
 * @param {String} table_name  Name of the table to check for existence.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_table = function(table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_table(table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/table", actual_request, callback);
};

/**
 * Check the existence of a type in GPUdb.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_type_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_type_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: request.type_id,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/has/type", actual_request, callback);
};

/**
 * Check the existence of a type in GPUdb.
 *
 * @param {String} type_id  Id of the type returned by GPUdb in response to
 *                          /create/type request.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.has_type = function(type_id, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.has_type(type_id, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: type_id,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/has/type", actual_request, callback);
};

/**
 * Adds multiple records to the specified table. The operation is synchronous
 * meaning that GPUdb will not return a response until all the records are
 * fully inserted and available. The response payload provides unique
 * identifier for each added record along with counts of the number of records
 * actually inserted and/or updated.
 * <p>
 * {@code options} can be used to customize this function's behavior. The only
 * parameter available is {@code update_on_existing_pk}. The value can be
 * either 'true' or 'false'. If the table has a /create/type and if {@code
 * update_on_existing_pk} is 'true' then if any of the records being added have
 * the same primary key as existing records, the existing records are replaced
 * (i.e. *updated*) with the given records. If {@code update_on_existing_pk} is
 * false and if the records being added have the same primary key as existing
 * records, the given records with existing primary keys are ignored (the
 * existing records are left unchanged). It is quite possible that in this case
 * some of the given records will be inserted and some (those having existing
 * primary keys) will be ignored (or updated). If the specified table does not
 * have a primary key column then the {@code update_on_existing_pk} option is
 * ignored.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        list: (request.list !== undefined && request.list !== null) ? request.list : [],
        list_str: (request.data !== undefined && request.data !== null) ? GPUdb.encode(request.data) : [],
        list_encoding: (request.list_encoding !== undefined && request.list_encoding !== null) ? request.list_encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/records", actual_request, callback);
};

/**
 * Adds multiple records to the specified table. The operation is synchronous
 * meaning that GPUdb will not return a response until all the records are
 * fully inserted and available. The response payload provides unique
 * identifier for each added record along with counts of the number of records
 * actually inserted and/or updated.
 * <p>
 * {@code options} can be used to customize this function's behavior. The only
 * parameter available is {@code update_on_existing_pk}. The value can be
 * either 'true' or 'false'. If the table has a /create/type and if {@code
 * update_on_existing_pk} is 'true' then if any of the records being added have
 * the same primary key as existing records, the existing records are replaced
 * (i.e. *updated*) with the given records. If {@code update_on_existing_pk} is
 * false and if the records being added have the same primary key as existing
 * records, the given records with existing primary keys are ignored (the
 * existing records are left unchanged). It is quite possible that in this case
 * some of the given records will be inserted and some (those having existing
 * primary keys) will be ignored (or updated). If the specified table does not
 * have a primary key column then the {@code update_on_existing_pk} option is
 * ignored.
 *
 * @param {String} table_name  Table to which the records are to be added. Must
 *                             be an existing table.
 * @param {Object[]} data  An array of JSON encoded data for the records to be
 *                         added. All records must be of the same type as that
 *                         of the table. Empty array if {@code list_encoding}
 *                         is {@code binary}.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records = function(table_name, data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records(table_name, data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        list: [],
        list_str: GPUdb.encode(data),
        list_encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/records", actual_request, callback);
};

/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that GPUdb will not return until all
 * random records are fully available.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_random_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_random_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        count: request.count,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/records/random", actual_request, callback);
};

/**
 * Generates a specified number of random records and adds them to the given
 * table. There is an optional parameter that allows the user to customize the
 * ranges of the column values. It also allows the user to specify linear
 * profiles for some or all columns in which case linear values are generated
 * rather than random ones. Only individual tables are supported for this
 * operation.
 * <p>
 * This operation is synchronous, meaning that GPUdb will not return until all
 * random records are fully available.
 *
 * @param {String} table_name  Table to which random records will be added.
 *                             Must be an existing table.  Also, must be an
 *                             individual table, not a collection of tables,
 *                             nor a view of a table.
 * @param {Number} count  Number of records to generate.
 * @param {Object} options  Optional parameter to pass in specifications for
 *                          the randomness of the values.  This map is
 *                          different from the *options* parameter of most
 *                          other endpoints in that it is a map of string to
 *                          map of string to doubles, while most others are
 *                          maps of string to string.  In this map, the top
 *                          level keys represent which column's parameters are
 *                          being specified, while the internal keys represents
 *                          which parameter is being specified.  The parameters
 *                          that can be specified are: *min*, *max*, and
 *                          *interval*.  These parameters take on different
 *                          meanings depending on the type of the column.
 *                          Below follows a more detailed description of the
 *                          map:
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_records_random = function(table_name, count, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_records_random(table_name, count, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        count: count,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/records/random", actual_request, callback);
};

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../rest/wms_rest.html" target="_top">WMS</a> or /visualize/image) if
 * the 'dosymbology' parameter is 'true' then GPUdb uses the value of the
 * 'SYMBOLCODE' column to pick the symbol displayed for each point.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_symbol_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_symbol_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        symbol_id: request.symbol_id,
        symbol_format: request.symbol_format,
        symbol_data: request.symbol_data,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/insert/symbol", actual_request, callback);
};

/**
 * Adds a symbol or icon (i.e. an image) to represent data points when data is
 * rendered visually. Users must provide the symbol identifier (string), a
 * format (currently supported: 'svg' and 'svg_path'), the data for the symbol,
 * and any additional optional parameter (e.g. color). To have a symbol used
 * for rendering create a table with a string column named 'SYMBOLCODE' (along
 * with 'x' or 'y' for example). Then when the table is rendered (via <a
 * href="../rest/wms_rest.html" target="_top">WMS</a> or /visualize/image) if
 * the 'dosymbology' parameter is 'true' then GPUdb uses the value of the
 * 'SYMBOLCODE' column to pick the symbol displayed for each point.
 *
 * @param {String} symbol_id  The id of the symbol being added. This is the
 *                            same id that should be in the 'SYMBOLCODE' column
 *                            for objects using this symbol
 * @param {String} symbol_format  Specifies the symbol format. Must be either
 *                                'svg' or 'svg_path'.
 * @param {String} symbol_data  The actual symbol data. If {@code
 *                              symbol_format} is 'svg' then this should be the
 *                              raw bytes representing an svg file. If {@code
 *                              symbol_format} is svg path then this should be
 *                              an svg path string, for example: 'M25.979,12.89
 *                              6,5.979,12.896,5.979,19.562,25.979,19.562z'
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.insert_symbol = function(symbol_id, symbol_format, symbol_data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.insert_symbol(symbol_id, symbol_format, symbol_data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        symbol_id: symbol_id,
        symbol_format: symbol_format,
        symbol_data: symbol_data,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/insert/symbol", actual_request, callback);
};

/**
 * Locks a table.  By default a table has no locks and all operations are
 * permitted.  A user may request a read-only or a write-only lock, after which
 * only read or write operations are permitted on the table until the next
 * request.  When lock_type is disable then then no operations are permitted on
 * the table.  The lock status can be queried by passing an empty string for
 * {@code lock_type}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.lock_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.lock_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        lock_type: (request.lock_type !== undefined && request.lock_type !== null) ? request.lock_type : "",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/lock/table", actual_request, callback);
};

/**
 * Locks a table.  By default a table has no locks and all operations are
 * permitted.  A user may request a read-only or a write-only lock, after which
 * only read or write operations are permitted on the table until the next
 * request.  When lock_type is disable then then no operations are permitted on
 * the table.  The lock status can be queried by passing an empty string for
 * {@code lock_type}.
 *
 * @param {String} table_name  Name of the table to be locked. It must be a
 *                             currently existing table and not a collection or
 *                             a view.
 * @param {String} lock_type  The type of lock being applied to the table or
 *                            blank to query. Empty string returns the lock
 *                            status without change the lock status of the
 *                            table.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.lock_table = function(table_name, lock_type, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.lock_table(table_name, lock_type, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        lock_type: (lock_type !== undefined && lock_type !== null) ? lock_type : "",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/lock/table", actual_request, callback);
};

/**
 * Returns server configuration and version related information to the caller.
 * The GPUdb Admin tool uses it to present server related information to the
 * user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_properties_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_properties_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/system/properties", actual_request, callback);
};

/**
 * Returns server configuration and version related information to the caller.
 * The GPUdb Admin tool uses it to present server related information to the
 * user.
 *
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_properties = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_properties(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/system/properties", actual_request, callback);
};

/**
 * Provides server configuration and health related status to the caller. The
 * GPUdb Admin tool uses it to present server related information to the user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_status_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_status_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/system/status", actual_request, callback);
};

/**
 * Provides server configuration and health related status to the caller. The
 * GPUdb Admin tool uses it to present server related information to the user.
 *
 * @param {Object} options  Optional parameters, currently unused.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_status = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_status(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/system/status", actual_request, callback);
};

/**
 * Returns the last 100 requests made to GPUdb along with the request timing
 * and internal job id. The GPUdb Admin tool uses it to present request timing
 * information to the user.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_timing_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_timing_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/system/timing", actual_request, callback);
};

/**
 * Returns the last 100 requests made to GPUdb along with the request timing
 * and internal job id. The GPUdb Admin tool uses it to present request timing
 * information to the user.
 *
 * @param {Object} options  Optional parameters, currently unused.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_system_timing = function(options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_system_timing(options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/system/timing", actual_request, callback);
};

/**
 * Retrieves detailed information about a particular GPUdb table, specified in
 * {@code table_name}. If the supplied {@code table_name} is a collection, the
 * call returns a list of tables contained in the collection, and for each
 * table it returns the description, type id, schema, type label, type
 * propertiess, and additional information including TTL. If {@code table_name}
 * is empty it will return all top-level tables including all collections and
 * top-level child tables (i.e. tables with no parent).
 * <p>
 *     If the option 'get_sizes' is set to 'true' then the sizes (objects and
 * elements) of each table are returned (in {@code sizes} and {@code
 * full_sizes}), along with the total number of objects in the requested table
 * (in {@code total_size} and {@code total_full_size}).
 * <p>
 *     If the option 'show_children' is set to 'false' then for a collection it
 * only returns information about the collection itself, not about the child
 * tables. If 'show_children' is set to 'true' then it will return information
 * about each of the children.
 * <p>
 *     Running with 'show_children' = 'true' on a child table will return an
 * error.
 * <p>
 *     Running with 'show_children' = 'false' with {@code table_name} empty
 * will return an error.
 * <p>
 * If the requested table is blank, then information is returned about all top-
 * level tables including collections.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/table", actual_request, callback);
};

/**
 * Retrieves detailed information about a particular GPUdb table, specified in
 * {@code table_name}. If the supplied {@code table_name} is a collection, the
 * call returns a list of tables contained in the collection, and for each
 * table it returns the description, type id, schema, type label, type
 * propertiess, and additional information including TTL. If {@code table_name}
 * is empty it will return all top-level tables including all collections and
 * top-level child tables (i.e. tables with no parent).
 * <p>
 *     If the option 'get_sizes' is set to 'true' then the sizes (objects and
 * elements) of each table are returned (in {@code sizes} and {@code
 * full_sizes}), along with the total number of objects in the requested table
 * (in {@code total_size} and {@code total_full_size}).
 * <p>
 *     If the option 'show_children' is set to 'false' then for a collection it
 * only returns information about the collection itself, not about the child
 * tables. If 'show_children' is set to 'true' then it will return information
 * about each of the children.
 * <p>
 *     Running with 'show_children' = 'true' on a child table will return an
 * error.
 * <p>
 *     Running with 'show_children' = 'false' with {@code table_name} empty
 * will return an error.
 * <p>
 * If the requested table is blank, then information is returned about all top-
 * level tables including collections.
 *
 * @param {String} table_name  Name of the table for which to retrieve the
 *                             information. If blank then information about all
 *                             collections and top-level tables is returned.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table = function(table_name, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table(table_name, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/table", actual_request, callback);
};

/**
 * Retrieves the user provided metadata for the specified tables.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_metadata_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_metadata_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/table/metadata", actual_request, callback);
};

/**
 * Retrieves the user provided metadata for the specified tables.
 *
 * @param {String[]} table_names  Tables whose metadata will be fetched. All
 *                                provided tables must exist in GPUdb, or GPUdb
 *                                returns an error.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_table_metadata = function(table_names, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_table_metadata(table_names, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/table/metadata", actual_request, callback);
};

/**
 * Gets names of the tables from GPUdb based on the type information. Each
 * table in GPUdb has a particular type. This type is made out of the type
 * label, schema of the table and the semantic type of the table. This function
 * allows a look up of the existing tables based on full or partial type
 * information. The operation is synchronous.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_tables_by_type_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_tables_by_type_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: request.type_id,
        label: request.label,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/tables/bytype", actual_request, callback);
};

/**
 * Gets names of the tables from GPUdb based on the type information. Each
 * table in GPUdb has a particular type. This type is made out of the type
 * label, schema of the table and the semantic type of the table. This function
 * allows a look up of the existing tables based on full or partial type
 * information. The operation is synchronous.
 *
 * @param {String} type_id  Type id returned by a call to /create/type.
 * @param {String} label  Optional user supplied label which can be used
 *                        instead of the type_id to retrieve all tables with
 *                        the given label.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_tables_by_type = function(type_id, label, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_tables_by_type(type_id, label, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: type_id,
        label: label,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/tables/bytype", actual_request, callback);
};

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active within GPUdb.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_triggers_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_triggers_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_ids: request.trigger_ids,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/triggers", actual_request, callback);
};

/**
 * Retrieves information regarding the specified triggers or all existing
 * triggers currently active within GPUdb.
 *
 * @param {String[]} trigger_ids  List of IDs of the triggers whose information
 *                                to be retrieved. Empty list means retrieve
 *                                information on all active triggers.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_triggers = function(trigger_ids, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_triggers(trigger_ids, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        trigger_ids: trigger_ids,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/triggers", actual_request, callback);
};

/**
 * Retrieves information for the specified data type. Given a type ID, GPUdb
 * returns the data type schema, the label, and the semantic type along with
 * the type ID. If the user provides any combination of label and semantic
 * type, then GPUdb returns the pertinent information for all data types that
 * match the input criteria.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_types_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_types_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: request.type_id,
        label: request.label,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/show/types", actual_request, callback);
};

/**
 * Retrieves information for the specified data type. Given a type ID, GPUdb
 * returns the data type schema, the label, and the semantic type along with
 * the type ID. If the user provides any combination of label and semantic
 * type, then GPUdb returns the pertinent information for all data types that
 * match the input criteria.
 *
 * @param {String} type_id  Type Id returned in response to a call to
 *                          /create/type.
 * @param {String} label  Option string that was supplied by user in a call to
 *                        /create/type.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.show_types = function(type_id, label, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.show_types(type_id, label, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        type_id: type_id,
        label: label,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/show/types", actual_request, callback);
};

/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in {@code new_values_maps}.  There is also an optional 'upsert'
 * capability where if a particular predicate doesn't match any existing
 * record, then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through {@code options}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        expressions: request.expressions,
        new_values_maps: request.new_values_maps,
        records_to_insert: (request.records_to_insert !== undefined && request.records_to_insert !== null) ? request.records_to_insert : [],
        records_to_insert_str: (request.data !== undefined && request.data !== null) ? GPUdb.encode(request.data) : [],
        record_encoding: (request.record_encoding !== undefined && request.record_encoding !== null) ? request.record_encoding : "json",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/update/records", actual_request, callback);
};

/**
 * Runs multiple predicate-based updates in a single call.  With the list of
 * given expressions, any matching record's column values will be updated as
 * provided in {@code new_values_maps}.  There is also an optional 'upsert'
 * capability where if a particular predicate doesn't match any existing
 * record, then a new record can be inserted.
 * <p>
 * Note that this operation can only be run on an original table and not on a
 * collection or a result view.
 * <p>
 * This operation can update primary key values.  By default only 'pure primary
 * key' predicates are allowed when updating primary key values. If the primary
 * key for a table is the column 'attr1', then the operation will only accept
 * predicates of the form: "attr1 == 'foo'" if the attr1 column is being
 * updated.  For a composite primary key (e.g. columns 'attr1' and 'attr2')
 * then this operation will only accept predicates of the form: "(attr1 ==
 * 'foo') and (attr2 == 'bar')".  Meaning, all primary key columns must appear
 * in an equality predicate in the expressions.  Furthermore each 'pure primary
 * key' predicate must be unique within a given request.  These restrictions
 * can be removed by utilizing some available options through {@code options}.
 *
 * @param {String} table_name  Table to be updated. Must be a currently
 *                             existing table and not a collection or view.
 * @param {String[]} expressions  A list of the actual predicates, one for each
 *                                update; format should follow the guidelines
 *                                /filter.
 * @param {Object[]} new_values_maps  List of new values for the matching
 *                                    records.  Each element is a map with
 *                                    (key, value) pairs where the keys are the
 *                                    names of the columns whose values are to
 *                                    be updated; the values are the new
 *                                    values.  The number of elements in the
 *                                    list should match the length of {@code
 *                                    expressions}.
 * @param {Object[]} data  An optional list of new json-avro encoded objects to
 *                         insert, one for each update, to be added to the set
 *                         if the particular update did not affect any objects.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records = function(table_name, expressions, new_values_maps, data, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records(table_name, expressions, new_values_maps, data, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        expressions: expressions,
        new_values_maps: new_values_maps,
        records_to_insert: [],
        records_to_insert_str: GPUdb.encode(data),
        record_encoding: "json",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/update/records", actual_request, callback);
};

/**
 * Updates the view specified by {@code table_name} to include full series
 * (track) information from the {@code world_table_name} for the series
 * (tracks) present in the {@code view_name}.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records_by_series_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records_by_series_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        world_table_name: request.world_table_name,
        view_name: (request.view_name !== undefined && request.view_name !== null) ? request.view_name : "",
        reserved: (request.reserved !== undefined && request.reserved !== null) ? request.reserved : [],
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/update/records/byseries", actual_request, callback);
};

/**
 * Updates the view specified by {@code table_name} to include full series
 * (track) information from the {@code world_table_name} for the series
 * (tracks) present in the {@code view_name}.
 *
 * @param {String} table_name  Name of the view on which the update operation
 *                             will be performed. Must be a valid view in
 *                             GPUdb.
 * @param {String} world_table_name  Name of the table containing the complete
 *                                   series (track) information.
 * @param {String} view_name  Optional name of the view containing the series
 *                            (tracks) which have to be updated.
 * @param {String[]} reserved
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.update_records_by_series = function(table_name, world_table_name, view_name, reserved, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.update_records_by_series(table_name, world_table_name, view_name, reserved, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        world_table_name: world_table_name,
        view_name: (view_name !== undefined && view_name !== null) ? view_name : "",
        reserved: (reserved !== undefined && reserved !== null) ? reserved : [],
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/update/records/byseries", actual_request, callback);
};

/**
 * Generates rasterized image tiles for an area of interest using the given
 * tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_image_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        world_table_names: request.world_table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        track_ids: request.track_ids,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        bg_color: request.bg_color,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image", actual_request, callback);
};

/**
 * Generates rasterized image tiles for an area of interest using the given
 * tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 *
 * @param {String[]} table_names  Name of the table containing the data for the
 *                                various layers to be rendered.
 * @param {String[]} world_table_names  Optional name of the tables containing
 *                                      the data for the entire track when the
 *                                      {@code table_names} contains only part
 *                                      of the track data, but the entire track
 *                                      has to be rendered.
 * @param {String} x_column_name  Name of the column containing the x
 *                                coordinates.
 * @param {String} y_column_name  Name of the column containing the y
 *                                coordinates.
 * @param {String[][]} track_ids  Tracks from the {@code table_names} to be
 *                                rendered.
 * @param {Number} min_x  Lower bound for the x values.
 * @param {Number} max_x  Upper bound for the x values.
 * @param {Number} min_y  Lower bound for the y values.
 * @param {Number} max_y  Upper bound for the y values.
 * @param {Number} width  Width of the generated image.
 * @param {Number} height  Height of the generated image.
 * @param {String} projection  Spatial Reference System (i.e. EPSG Code).
 * @param {Number} bg_color  Background color of the generated image
 * @param {Object} style_options  Styling options for the image.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_image = function(table_names, world_table_names, x_column_name, y_column_name, track_ids, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image(table_names, world_table_names, x_column_name, y_column_name, track_ids, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        world_table_names: world_table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        track_ids: track_ids,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        bg_color: bg_color,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image", actual_request, callback);
};

/**
 * Generates 'class break' rasterized image tiles for an area of interest using
 * the given tables and the provided parameters.
 * <p>
 * A class break rendering is where data from one or more GPUdb tables is
 * rasterized with styling applied on a per-class basis. GPUdb supports class
 * breaks based on one or more data columns. Distinct values (for strings) or
 * ranges (for numeric attributes) must be provided in the
 * cb_column_name1/cb_vals1 and cb_column_name2/cb_vals2 parameters. The
 * styling parameters must be specified for each class.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The image is contained in the {@code image_data} field.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_image_classbreak_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_classbreak_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        world_table_names: request.world_table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        track_ids: request.track_ids,
        cb_column_name1: request.cb_column_name1,
        cb_vals1: request.cb_vals1,
        cb_column_name2: request.cb_column_name2,
        cb_vals2: request.cb_vals2,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        bg_color: request.bg_color,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image/classbreak", actual_request, callback);
};

/**
 * Generates 'class break' rasterized image tiles for an area of interest using
 * the given tables and the provided parameters.
 * <p>
 * A class break rendering is where data from one or more GPUdb tables is
 * rasterized with styling applied on a per-class basis. GPUdb supports class
 * breaks based on one or more data columns. Distinct values (for strings) or
 * ranges (for numeric attributes) must be provided in the
 * cb_column_name1/cb_vals1 and cb_column_name2/cb_vals2 parameters. The
 * styling parameters must be specified for each class.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The image is contained in the {@code image_data} field.
 *
 * @param {String[]} table_names  Name of the table containing the data for the
 *                                various layers to be rendered.
 * @param {String[]} world_table_names  Optional name of the tables containing
 *                                      the data for the entire track when the
 *                                      {@code table_names} contains only part
 *                                      of the track data, but the entire track
 *                                      has to be rendered.
 * @param {String} x_column_name  Name of the column containing the x
 *                                coordinates.
 * @param {String} y_column_name  Name of the column containing the y
 *                                coordinates.
 * @param {String[][]} track_ids  Tracks from the {@code table_names} to be
 *                                rendered.
 * @param {String} cb_column_name1  Name of the column for the first class
 *                                  break.
 * @param {String[]} cb_vals1  Comma separated list of values or ranges (e.g.
 *                             '0:5,5:10,15:30').
 * @param {String[]} cb_column_name2  Optional comma seperated list of valid
 *                                    column names. An empty string implies not
 *                                    using more than one column for the class
 *                                    break. For a non-empty list, there needs
 *                                    to be as many entries in the list as
 *                                    there are classes for the first column
 *                                    ({@code cb_column_name1}). However, the
 *                                    column names can be empty to indicate
 *                                    that for the corresponding class of the
 *                                    first attribute, no secondary class break
 *                                    will be applied. All the column names in
 *                                    this list must be different from the
 *                                    first column {@code cb_column_name1}. For
 *                                    example, 'col2,col3,col2'.
 * @param {String[][]} cb_vals2  Comma separated list of []-enclosed lists of
 *                               values or ranges; e.g.
 *                               '[0:5,5:10],[of,on,so],[-50:-20]'. Each square
 *                               bracket enclosed list describes the secondary
 *                               classes for the respective attribute in {@code
 *                               cb_column_name2} and the respective class in
 *                               {@code cb_column_name1} / {@code cb_vals1}.
 * @param {Number} min_x  Lower bound for the x values.
 * @param {Number} max_x  Upper bound for the x values.
 * @param {Number} min_y  Lower bound for the y values.
 * @param {Number} max_y  Upper bound for the y values.
 * @param {Number} width  Width of the generated image.
 * @param {Number} height  Height of the generated image.
 * @param {String} projection  Spatial Reference System (i.e. EPSG Code).
 * @param {Number} bg_color  Background color of the generated image.
 * @param {Object} style_options  Styling options for the image.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_image_classbreak = function(table_names, world_table_names, x_column_name, y_column_name, track_ids, cb_column_name1, cb_vals1, cb_column_name2, cb_vals2, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_classbreak(table_names, world_table_names, x_column_name, y_column_name, track_ids, cb_column_name1, cb_vals1, cb_column_name2, cb_vals2, min_x, max_x, min_y, max_y, width, height, projection, bg_color, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        world_table_names: world_table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        track_ids: track_ids,
        cb_column_name1: cb_column_name1,
        cb_vals1: cb_vals1,
        cb_column_name2: cb_column_name2,
        cb_vals2: cb_vals2,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        bg_color: bg_color,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image/classbreak", actual_request, callback);
};

/**
 * Generates rasterized heatmap image tiles for an area of interest using the
 * given tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The heatmap image is contained in the {@code image_data} field.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_image_heatmap_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_heatmap_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        value_column_name: request.value_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image/heatmap", actual_request, callback);
};

/**
 * Generates rasterized heatmap image tiles for an area of interest using the
 * given tables and the provided parameters.
 * <p>
 * All color values must be in the format RRGGBB or AARRGGBB (to specify the
 * alpha value).
 * The heatmap image is contained in the {@code image_data} field.
 *
 * @param {String[]} table_names  Name of the table containing the data for the
 *                                various layers to be rendered.
 * @param {String} x_column_name  Name of the column containing the x
 *                                coordinates.
 * @param {String} y_column_name  Name of the column containing the y
 *                                coordinates.
 * @param {String} value_column_name
 * @param {Number} min_x  Lower bound for the x values.
 * @param {Number} max_x  Upper bound for the x values.
 * @param {Number} min_y  Lower bound for the y values.
 * @param {Number} max_y  Upper bound for the y values.
 * @param {Number} width  Width of the generated image.
 * @param {Number} height  Height of the generated image.
 * @param {String} projection  Spatial Reference System (i.e. EPSG Code).
 * @param {Object} style_options  Various style related options.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_image_heatmap = function(table_names, x_column_name, y_column_name, value_column_name, min_x, max_x, min_y, max_y, width, height, projection, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_heatmap(table_names, x_column_name, y_column_name, value_column_name, min_x, max_x, min_y, max_y, width, height, projection, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        value_column_name: value_column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image/heatmap", actual_request, callback);
};

/**
 * Generates a rasterized image tile containing text labels defined by data
 * contained in the given table, suitable for overlaying onto a feature image
 * tile covering the same area (for example one generated using
 * /visualize/image).
 * <p>
 * All color values must be integers encoded in the format RRGGBB or AARRGGBB
 * (to specify the alpha value) when represented in hexadecimal; although note
 * that literal color values must be specified in base 10, not hexadecimal.
 * <p>
 * Fonts are specified as strings of the form 'FAMILY STYLE-OPTIONS SIZE',
 * where FAMILY is the font family, STYLE-OPTIONS is a whitespace separated
 * list of words defining style, variant, weight, stretch, or gravity, and SIZE
 * is a decimal number (size in points) or optionally followed by the unit
 * modifier 'px' for absolute size. All three sub-fields are optional; default
 * values will be used for omitted sub-fields. (For example, 'Helvetica Bold
 * Italic 10' specifies Helvetica, Bold and Italic, 10 points.) A substitute
 * font will be used if a requested font is not installed.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_image_labels_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_labels_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: request.table_name,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        x_offset: request.x_offset,
        y_offset: request.y_offset,
        text_string: request.text_string,
        font: request.font,
        text_color: request.text_color,
        text_angle: request.text_angle,
        text_scale: request.text_scale,
        draw_box: request.draw_box,
        draw_leader: request.draw_leader,
        line_width: request.line_width,
        line_color: request.line_color,
        fill_color: request.fill_color,
        leader_x_column_name: request.leader_x_column_name,
        leader_y_column_name: request.leader_y_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/image/labels", actual_request, callback);
};

/**
 * Generates a rasterized image tile containing text labels defined by data
 * contained in the given table, suitable for overlaying onto a feature image
 * tile covering the same area (for example one generated using
 * /visualize/image).
 * <p>
 * All color values must be integers encoded in the format RRGGBB or AARRGGBB
 * (to specify the alpha value) when represented in hexadecimal; although note
 * that literal color values must be specified in base 10, not hexadecimal.
 * <p>
 * Fonts are specified as strings of the form 'FAMILY STYLE-OPTIONS SIZE',
 * where FAMILY is the font family, STYLE-OPTIONS is a whitespace separated
 * list of words defining style, variant, weight, stretch, or gravity, and SIZE
 * is a decimal number (size in points) or optionally followed by the unit
 * modifier 'px' for absolute size. All three sub-fields are optional; default
 * values will be used for omitted sub-fields. (For example, 'Helvetica Bold
 * Italic 10' specifies Helvetica, Bold and Italic, 10 points.) A substitute
 * font will be used if a requested font is not installed.
 *
 * @param {String} table_name  Name of the table containing the data defining
 *                             the labels to render.
 * @param {String} x_column_name  Name of the column containing the x
 *                                coordinates of the center points of the
 *                                labels.
 * @param {String} y_column_name  Name of the column containing the y
 *                                coordinates of the center points of the
 *                                labels.
 * @param {String} x_offset  Either the name of an integer column, or a single
 *                           literal integer value, defining the number of
 *                           output pixels by which the labels will be offset
 *                           horizontally from their specified x coordinates.
 *                           If blank, an offset of 0 will be used.
 * @param {String} y_offset  Either the name of an integer column, or a single
 *                           literal integer value, defining the number of
 *                           output pixels by which the labels will be offset
 *                           vertically from their specified y coordinates. If
 *                           blank, an offset of 0 will be used.
 * @param {String} text_string  Either the name of a string column, or a single
 *                              literal string value (enclosed in double
 *                              quotes), defining the text for the labels.
 * @param {String} font  Either the name of a string column, or a single
 *                       literal string value (enclosed in double quotes),
 *                       defining the fonts for the labels.
 * @param {String} text_color  Either the name of an integer column, or a
 *                             single literal integer value, defining the text
 *                             color for the labels. If blank, opaque black
 *                             will be used.
 * @param {String} text_angle  Either the name of a numeric column, or a single
 *                             literal numeric value, defining the angle of
 *                             clockwise rotation (in degrees) for the labels.
 *                             If blank, an angle of 0 will be used.
 * @param {String} text_scale  Either the name of a numeric column, or a single
 *                             literal numeric value, defining the scaling
 *                             factor for the labels. (1 is normal size, 0.5 is
 *                             half size, 2 is double size, etc.) If blank, a
 *                             scaling factor of 1 will be used.
 * @param {String} draw_box  Either the name of an integer column, or a single
 *                           literal integer value, defining a Boolean flag
 *                           indicating whether boxes will be drawn around the
 *                           labels. If blank, no boxes will be drawn.
 * @param {String} draw_leader  Either the name of an integer column, or a
 *                              single literal integer value, defining a
 *                              Boolean flag indicating whether leader lines
 *                              will be drawn from the labels to points
 *                              specified using {@code leader_x_column_name}
 *                              and {@code leader_y_column_name}. If blank, no
 *                              leader lines will be drawn.
 * @param {String} line_width  Either the name of a numeric column, or a single
 *                             literal numeric value, defining the line width
 *                             in output pixels for the labels' boxes and
 *                             leader lines. If blank, a line width of 1 will
 *                             be used.
 * @param {String} line_color  Either the name of an integer column, or a
 *                             single literal integer value, defining the line
 *                             color for the labels' boxes and leader lines. If
 *                             blank, opaque black will be used.
 * @param {String} fill_color  Either the name of an integer column, or a
 *                             single literal integer value, defining the fill
 *                             color for the labels' boxes. If blank, the boxes
 *                             will not be filled.
 * @param {String} leader_x_column_name  Name of the column containing the x
 *                                       coordinates of the points to which the
 *                                       labels' leader lines will be drawn.
 *                                       May be left blank if no leader lines
 *                                       are to be drawn.
 * @param {String} leader_y_column_name  Name of the column containing the y
 *                                       coordinates of the points to which the
 *                                       labels' leader lines will be drawn.
 *                                       May be left blank if no leader lines
 *                                       are to be drawn.
 * @param {Number} min_x  Lower bound for the x coordinates of labels to
 *                        include in the image.
 * @param {Number} max_x  Upper bound for the x coordinates of labels to
 *                        include in the image.
 * @param {Number} min_y  Lower bound for the y coordinates of labels to
 *                        include in the image.
 * @param {Number} max_y  Upper bound for the y coordinates of labels to
 *                        include in the image.
 * @param {Number} width  Width of the generated image.
 * @param {Number} height  Height of the generated image.
 * @param {String} projection  Spatial Reference System (i.e. EPSG Code).
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_image_labels = function(table_name, x_column_name, y_column_name, x_offset, y_offset, text_string, font, text_color, text_angle, text_scale, draw_box, draw_leader, line_width, line_color, fill_color, leader_x_column_name, leader_y_column_name, min_x, max_x, min_y, max_y, width, height, projection, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_image_labels(table_name, x_column_name, y_column_name, x_offset, y_offset, text_string, font, text_color, text_angle, text_scale, draw_box, draw_leader, line_width, line_color, fill_color, leader_x_column_name, leader_y_column_name, min_x, max_x, min_y, max_y, width, height, projection, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_name: table_name,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        x_offset: x_offset,
        y_offset: y_offset,
        text_string: text_string,
        font: font,
        text_color: text_color,
        text_angle: text_angle,
        text_scale: text_scale,
        draw_box: draw_box,
        draw_leader: draw_leader,
        line_width: line_width,
        line_color: line_color,
        fill_color: fill_color,
        leader_x_column_name: leader_x_column_name,
        leader_y_column_name: leader_y_column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/image/labels", actual_request, callback);
};

/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images ({@code
 * bg_color}, {@code width}, {@code height}), the collection of GPUdb table
 * names on which this function is to be applied, for which shapes (point,
 * polygon, tracks) the images are to be created and a user specified session
 * key. This session key is later used to fetch the generated images stored by
 * GPUdb. The operation is synchronous meaning that GPUdb will not return the
 * request until the images for all the frames of the video are fully
 * available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in {@code
 * session_key} of the visualize video request and the FRAME parameter
 * indicates which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * The response payload provides, among other things, the number of frames
 * which were created by GPUdb.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_video_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_video_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        world_table_names: request.world_table_names,
        track_ids: request.track_ids,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        bg_color: request.bg_color,
        time_intervals: request.time_intervals,
        video_style: request.video_style,
        session_key: request.session_key,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/video", actual_request, callback);
};

/**
 * Creates raster images of data in the given table based on provided input
 * parameters. Numerous parameters are required to call this function. Some of
 * the important parameters are the attributes of the generated images ({@code
 * bg_color}, {@code width}, {@code height}), the collection of GPUdb table
 * names on which this function is to be applied, for which shapes (point,
 * polygon, tracks) the images are to be created and a user specified session
 * key. This session key is later used to fetch the generated images stored by
 * GPUdb. The operation is synchronous meaning that GPUdb will not return the
 * request until the images for all the frames of the video are fully
 * available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in {@code
 * session_key} of the visualize video request and the FRAME parameter
 * indicates which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * The response payload provides, among other things, the number of frames
 * which were created by GPUdb.
 *
 * @param {String[]} table_names  Names of the tables containing the data for
 *                                various layers of the resulting video.
 * @param {String[]} world_table_names  Optional name of the tables containing
 *                                      the data for the entire track when the
 *                                      {@code table_names} contains only part
 *                                      of the track data, but the entire track
 *                                      has to be rendered. The number of
 *                                      tables should match the number of
 *                                      tables in the {@code table_names}
 * @param {String[][]} track_ids  Tracks from the {@code table_names} to be
 *                                rendered.
 * @param {String} x_column_name  Name of the column containing the x
 *                                coordinates.
 * @param {String} y_column_name  Name of the column containing the y
 *                                coordinates.
 * @param {Number} min_x  Lower bound for the x values.
 * @param {Number} max_x  Upper bound for the x values.
 * @param {Number} min_y  Lower bound for the y values.
 * @param {Number} max_y  Upper bound for the y values.
 * @param {Number} width  Width of the generated image.
 * @param {Number} height  Height of the generated image.
 * @param {String} projection  Spatial Reference System (i.e. EPSG Code).
 * @param {Number} bg_color  Background color of the generated image.
 * @param {Number[][]} time_intervals
 * @param {String} video_style
 * @param {String} session_key  User Provided session key that is later used to
 *                              retrieve the generated video from the WMS.
 * @param {Object} style_options  Styling options for the image.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_video = function(table_names, world_table_names, track_ids, x_column_name, y_column_name, min_x, max_x, min_y, max_y, width, height, projection, bg_color, time_intervals, video_style, session_key, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_video(table_names, world_table_names, track_ids, x_column_name, y_column_name, min_x, max_x, min_y, max_y, width, height, projection, bg_color, time_intervals, video_style, session_key, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        world_table_names: world_table_names,
        track_ids: track_ids,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        bg_color: bg_color,
        time_intervals: time_intervals,
        video_style: video_style,
        session_key: session_key,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/video", actual_request, callback);
};

/**
 * Creates raster heat-map images of table data based on input parameters.
 * Numerous parameters are required to call this function. Some of the
 * important parameters are the attributes of the generated images ({@code
 * bg_color}, {@code width}, {@code height}), the collection of GPUdb table
 * names on which this function is to be applied and a user specified session
 * key. This session key is later used to fetch the generated images stored by
 * GPUdb. The operation is synchronous meaning that GPUdb will not return the
 * request until all the images are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in {@code
 * session_key} of the visualize video request and the FRAME parameter
 * indicates which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * <p>

 * <p>

 * The response payload provides among other things the number of frames which
 * were created by GPUdb.
 *
 * @param {Object} request  Request object containing the parameters for the
 *                          operation.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_video_heatmap_request = function(request, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_video_heatmap_request(request, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: request.table_names,
        x_column_name: request.x_column_name,
        y_column_name: request.y_column_name,
        min_x: request.min_x,
        max_x: request.max_x,
        min_y: request.min_y,
        max_y: request.max_y,
        time_intervals: request.time_intervals,
        width: request.width,
        height: request.height,
        projection: (request.projection !== undefined && request.projection !== null) ? request.projection : "PLATE_CARREE",
        video_style: request.video_style,
        session_key: request.session_key,
        style_options: request.style_options,
        options: (request.options !== undefined && request.options !== null) ? request.options : {}
    };

    this.submit_request("/visualize/video/heatmap", actual_request, callback);
};

/**
 * Creates raster heat-map images of table data based on input parameters.
 * Numerous parameters are required to call this function. Some of the
 * important parameters are the attributes of the generated images ({@code
 * bg_color}, {@code width}, {@code height}), the collection of GPUdb table
 * names on which this function is to be applied and a user specified session
 * key. This session key is later used to fetch the generated images stored by
 * GPUdb. The operation is synchronous meaning that GPUdb will not return the
 * request until all the images are fully available.
 * <p>
 * Once the request has been processed then the generated video frames are
 * available for download via WMS using STYLES=cached. In this request the
 * LAYERS parameter should be populated with the session key passed in {@code
 * session_key} of the visualize video request and the FRAME parameter
 * indicates which 0-based frame of the video should be returned. All other WMS
 * parameters are ignored for this mode.
 * <p>
 * For instance, if a 20 frame video with the session key 'MY-SESSION-KEY' was
 * generated, the first frame could be retrieved with the URL::
 * <p>
 *      http://<gpudb-ip-address>:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS
 * =MY-SESSION-KEY&FRAME=0
 * <p>
 * and the last frame could be retrieved with::
 * <p>
 *     http://gpudb-ip-address:9191/wms?REQUEST=GetMap&STYLES=cached&LAYERS=MY-
 * SESSION-KEY&FRAME=19
 * <p>

 * <p>

 * The response payload provides among other things the number of frames which
 * were created by GPUdb.
 *
 * @param {String[]} table_names  Names of the tables containing the data for
 *                                various layers of the resulting video
 * @param {String} x_column_name  Name of the column containing the x
 *                                coordinates.
 * @param {String} y_column_name  Name of the column containing the y
 *                                coordinates.
 * @param {Number} min_x  Lower bound for the x values.
 * @param {Number} max_x  Upper bound for the x values.
 * @param {Number} min_y  Lower bound for the y values.
 * @param {Number} max_y  Upper bound for the y values.
 * @param {Number[][]} time_intervals
 * @param {Number} width  Width of the generated video.
 * @param {Number} height  Height of the generated video.
 * @param {String} projection  Spatial Reference System (i.e. EPSG Code).
 * @param {String} video_style
 * @param {String} session_key  User Provided session key that is later used to
 *                              retrieve the generated video from the WMS.
 * @param {Object} style_options  Various style related options.
 * @param {Object} options  Optional parameters.
 * @param {GPUdbCallback} callback  Callback that handles the response.
 * 
 * @returns {Promise} A promise that will be fulfilled with the response
 *                    object, if no callback function is provided.
 */
GPUdb.prototype.visualize_video_heatmap = function(table_names, x_column_name, y_column_name, min_x, max_x, min_y, max_y, time_intervals, width, height, projection, video_style, session_key, style_options, options, callback) {
    if (callback === undefined || callback === null) {
        var self = this;

        return new Promise( function( resolve, reject) {
            self.visualize_video_heatmap(table_names, x_column_name, y_column_name, min_x, max_x, min_y, max_y, time_intervals, width, height, projection, video_style, session_key, style_options, options, function(err, response) {
                if (err !== null) {
                    reject(err);
                } else {
                    resolve( response );
                }
            });
        });
    }

    var actual_request = {
        table_names: table_names,
        x_column_name: x_column_name,
        y_column_name: y_column_name,
        min_x: min_x,
        max_x: max_x,
        min_y: min_y,
        max_y: max_y,
        time_intervals: time_intervals,
        width: width,
        height: height,
        projection: (projection !== undefined && projection !== null) ? projection : "PLATE_CARREE",
        video_style: video_style,
        session_key: session_key,
        style_options: style_options,
        options: (options !== undefined && options !== null) ? options : {}
    };

    this.submit_request("/visualize/video/heatmap", actual_request, callback);
};
